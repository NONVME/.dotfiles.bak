*intro.txt*     Для Vim version 6.3.  Последнее изменение: 2004 May 01


		      СПРАВОЧНИК ПО VIM  Брам Мооленаар


Введение в Vim			                *ref* *reference* *справочник*

1. Введение    			|введение|
2. Vim в интернете    		|интернет|
3. Авторы			|авторы|
4. Соглашения			|соглашения|
5. Введение в режимы Vim	|режимы_vim|
6. Переключение между режимами	|переключение_режимов|
7. Содержимое окна		|содержимое_окна|
8. Определения			|определения|

==============================================================================
1. Введение    						    *intro* *введение*

Vim это сокращение от Vi IMproved (Улучшенный Vi). Первоначально это
сокращение использовалось для Vi IMitation ("Имитация Vi"), но улучшений было
настолько много, что изменение названия оказалось оправданным. Vim это
текстовый редактор, который включает практически все команды из программы
"Vi", распространённой в системе Unix, а также множество новых. Он чрезвычайно
полезен для редактирования программ и другой текстовой информации.
   Все команды можно отдавать при помощи клавиатуры. Для тех, кто любит
держать руки на клавиатуре и смотреть на экран это большое преимущество. Кроме
того, имеется версия с графическим интерфейсом, с прокруткой документа, меню и
поддержкой мыши (см. |gui.txt|).

Краткое содержание этого руководства можно найти в файле "help.txt",
|help.txt|. Из Vim этот файл доступен при нажатии кнопки <Help> или <F1> и при
помощи команды |:help| (просто наберите ":help", без кавычек и вертикальных
линий).
   Опция 'helpfile' может указывать на другое имя файла, в том случае, если он
находится в каком-то другом месте. По темам можно перемещаться при помощи
меток: для перемещения к теме, расположенной под курсором нажмите CTRL-], для
возврата нажмите CTRL-T.

Повсюду в этом руководстве различия между Vi и Vim отмечаются в фигурных
скобках, например: {Vi не имеет встроенного справочника}. См. |vi_diff.txt|
для общей информации о различиях между Vim и Vi.

Это руководство относится к использованию Vim на различных машинах. Между
разными компьютерами и терминалами могут быть незначительные различия. Помимо
комментариев в этом документе, существует также отдельный документ для каждой
системы, на которой присутствует Vim, см. |список_файлов_о_системах|.

Это руководство является справочником по всем командам и опциям Vim. Оно не
является введением в использование Vi или Vim, но подробно описывает детали,
связанные с работой в редакторе. Для начинающих существует небольшой
|учебник|. Для изучения Vim также читайте руководство пользователя
|usr_toc.txt|.

							        *book* *книги*
Vi посвящено множество книг, в которых содержатся сведения для начинающих. Я
могу порекомендовать, в частности, две книги:

	"Vim - Vi Improved" Стива Уаллина (Steve Oualline)

Это самая первая книга, целиком посвященная Vim. Она очень хороша для
начинающих. Наиболее часто используемые команды объясняются на примерах и с
иллюстрациями. В книге также разбираются и менее часто используемые команды,
обобщенно даются и более сложные особенности. В книге есть подробный указатель
и краткий справочник. Частично материалы из книги входят в руководство
|из_книги|.
Книга издана New Riders Publishing.  ISBN: 0735710015
Более подробную информацию можно получить в интернете:

	http://iccf-holland.org/click5.html
	http://www.vim.org/iccf/click5.html

	"Learning the Vi editor" Линды Ламб (Linda Lamb) и 
				 Арнольда Роббинса (Arnold Robbins)
				 
Это книга о редакторе Vi, в которой также есть глава о Vim (в шестом издании).
Первые шаги в редакторе Vi объясняются в ней очень хорошо. Команды, которые
есть только в Vim затронуты только вскользь. Эта книга переведена на немецкий.
Книга издана O'Reilly.  ISBN: 1-56592-426-6.

==============================================================================
2. Vim в интернете    					 *internet* *интернет*
				   *www* *faq* *FAQ* *distribution* *download*
На страницах Vim в интернете содержится самая последняя информация о Vim. Там
также содержатся ссылки на самые последние версии Vim. FAQ это список наиболее
часто задаваемых вопросов. Вы можете обратиться к нему, если столкнетесь с
проблемами.

	Домашняя страница VIM:	http://www.vim.org/
	VIM FAQ:		http://vimdoc.sf.net/
	Скачать программу:	ftp://ftp.vim.org/pub/vim/MIRRORS


Группы новостей Usenet, где обсуждается Vim is discussed:      *news* *usenet*

	comp.editors

В этой группе новостей также обсуждаются и другие программы-редакторы. Если вы
пишите о Vim, то не забывайте это указывать.

					     *mail-list* *maillist* *рассылку*
							            *рассылка*
Vim посвящено несколько почтовых рассылок:

<vim@vim.org>
	Для обсуждения существующих версий Vim: полезные настройки, вопросы,
	ответы, где взять ту или иную версию и т.д.

<vim-dev@vim.org>				            *vim-dev* *vimdev*
	Для обсуждения изменений в Vim: новые особенности, портирование на
	другие платформы, исправления, бета-версии и т.д.
	
<vim-announce@vim.org>				                *vim-announce*
	Объявления о новых версиях Vim; также для бета-версий и портах на
	различные системы.
	
<vim-multibyte@vim.org>				               *vim-multibyte*
	Для обсуждений об использовании и улучшении мультибайтовых аспектов
	Vim.
	
<vim-mac@vim.org>				                     *vim-mac*
	Для обсуждения использования и улучшения версии Vim для Macintosh.

См. свежую информацию в интернете по адресу http://www.vim.org/maillist.php.

ЗАМЕЧАНИЕ:
- В эти списки рассылки можно отправлять письма только если вы подписаны!
- Письма в список можно отправлять только с того же адреса, с которого вы
  подписаны (чтобы спама не было).
- Максимальный размер сообщений 40000 символов.

				   *subscribe-maillist* *подписка-на-рассылку*
Если вы хотите подписаться, то отправьте сообщение по адресу
	<vim-help@vim.org>
Убедитесь, что ваш адрес "From:" правильный. Сервер рассылки пришлет вам
дальнейшие указания о том, как подписаться.

Сервер также может выслать вам старые сообщения и список сообщений. Все
инструкции содержатся в ответе от vim-help.

Архивы рассылки хранятся:                 *maillist-archive* *архивы-рассылки*
http://groups.yahoo.com/group/vim
http://groups.yahoo.com/group/vimdev
http://groups.yahoo.com/group/vimannounce
http://groups.yahoo.com/group/vim-multibyte
http://groups.yahoo.com/group/vim-mac


Дополнительные почтовые рассылки:

<vim-fr@club.voila.fr>				             *french-maillist*
	Рассылка Vim на французском. Подписаться можно отправив сообщение на
		<vim-fr-subscribe@club.voila.fr>
	Или можно посмотреть здесь: http://groups.yahoo.com/group/vim-fr.


	                                  *bugs* *bug-reports* *bugreport.vim*
						          *ошибки_в_программе*
								       *глюки*
Сообщения об ошибках в программе:

Сообщения об ошибках отправляйте по адресу: Vim bugs <bugs@vim.org>
Это не список рассылки, но все сообщения, приходящие по этому адресу,
переадресуются разработчикам. Постарайтесь быть краткими; время, которое
приходится тратить, отвечая на письма, вычитается из времени, предназначенного
для улучшения Vim! Всегда приводите пример, который можно повторить и
постарайтесь найти самостоятельно какие настройки способствуют появлению
ошибки. Если есть возможность, попробуйте повторить пример на различных
системах. Если Вы можете, то присылайте готовый код с исправлениями!

При возникновении сомнений используйте: >
   :so $VIMRUNTIME/bugreport.vim
Эта команда создаст файл "bugreport.txt" в текущем каталоге, в котором
содержится масса информации о вашей системе. Перед отправкой убедитесь, что в
нем не содержится какой-либо конфиденциальной информации!

						     *debug-vim* *отладка_vim*
Если Vim аварийно прекращает работу с одним из тестовых файлов, и вы
используете для компиляции gcc, то, чтобы выяснить где именно Vim прекращает
работу, можно проделать следующее:

1. Скомпилируйте Vim с ключом "-g" (В Makefile есть строка, которая включает
   этот ключ, которую нужно раскомментировать).

2. Выполните следующие команды (замените "11" на тест, который приводит к
   завершению работы): >
	cd testdir
	gdb ../vim
	run -u unix.vim -U NONE -s dotest.in test11.in

3. Проверьте, где Vim прекращает работу, gdb должен выдать сообщение об этом.

4. Получите от gdb состояние стека: >
	where
<  Различные места в стеке можно проверить командой: >
	frame 3
<  "3" надо заменить на один из номеров в диагностике состоянии стека.

					     *year-2000* *Y2K* *проблема_2000*
Поскольку внутренний код Vim не использует для работы даты, то проблема 2000
года как таковая не имеет отношения к редактору. Vim использует время в форме
секунд, прошедших после 1 января 1970 года. Это время используется для
проверки и сравнения отметок о времени редактирования в текущем файле и в
своп-файле, что не является критическим и приводит только к предупреждающим
сообщениям.

Возможно возникновение проблемы 2038 года, когда количество секунд, прошедших
после 1 января 1970 года больше не будет умещаться в 32-битное целое число.
Данная проблема напрямую связана с компилятором, библиотеками и операционной
системой. Говоря точнее, используются time_t и функция ctime(). Значение
time_t хранится в своп-файле в четырех байтах, но используется только для
диагностики времени и даты файла при восстановлении и никак не влияет на
обычное редактирование.

Функция Vim strftime() напрямую использует системную функцию strftime().
localtime() использует системную функцию time(). getftime() использует время,
возвращаемое системной функцией stat(). Если ваши системные библиотеки готовы
к 2000-му году, то можно сказать тоже самое и о Vim.

Пользователь может создать сценарии для Vim, которые используют внешние
команды. Такие сценарии могут быть подвержены проблеме 2000 года, но они не
имеют прямого отношения к самому редактору Vim.

==============================================================================
3. Авторы			                   *credits* *author* *авторы*

Большая часть Vim написана Брамом Мооленаар (Bram Moolenaar) <Bram@vim.org>.

Отдельные фрагменты документации взяты из нескольких руководств по Vi,
написанных
	У.Н. Джой (W.N. Joy)
	Аланом П.У. Хьюитт (Alan P.W. Hewett)
	Марком Хортоном (Mark Horton)

Редактор Vim основан на Stevie и включает идеи и фрагменты из другого
программного обеспечения, над которым работали люди, упомянутые здесь. Другие
оказали помощь с исправлениями, предложениями и своими мнениями о том, что в Vim
хорошо и что плохо.

Vim никогда не был бы тем, чем он является, без помощи этих людей!

	Рон Аарон          (Ron Aaron)          Изменения в графическом интерфейсе 
	                                           Win32
	Золтан Арпаддфи    (Zoltan Arpadffy)    Работа над портом на VMS
	Тони Эндрюз        (Tony Andrews)       Stevie
	Герт ван Антверпен (Gert van Antwerpen) Изменения для DJGPP на MS-DOS
	Berkeley DB(3)				идеи по реализации своп-файла
	Кейт Бостик        (Keith Bostic)       Nvi
	Уолтер Брискоу     (Walter Briscoe)     Поддержка Makefile, различные
	                                           исправления
        Ральф Браун        (Ralf Brown)         Библиотека SPAWNO для MS-DOS
	Роберт Колон       (Robert Colon)       Множество полезных замечаний
	Марчин Далечки     (Marcin Dalecki)     Порт для GTK+ GUI, кнопки
	                                           панели, gettext()
	Кейхан Демирел     (Kayhan Demirel)     сообщал мне о новостях в
	                                           Уганде
	Крис и Джон Дауни  (Chris&John Downey)  xvi (идеи для многооконной
	                                           версии)
	Хенк Элберс        (Henk Elbers)        Первый порт на VMS
	Эрик Фишер         (Eric Fischer)       Порт на Mac, 'cindent', 
	                                           и другие усовершенствования
	Бенджи Фишер       (Benji Fisher)       Ответы на многочисленные 
	                                           вопросы пользователей
	Билл Фостер        (Bill Foster)        Порт Athena GUI
	Лойк Грени         (Loic Grenie)        xvim (идеи для многооконной
	                                           версии)
	Свен Гуккес        (Sven Guckes)        Популяризатор Vim, прежний
 	                                           веб-мастер www-сайта
	Даррен Хиберт      (Darren Hiebert)     exuberant ctags
	Брюс Хансейкер     (Bruce Hunsaker)     улучшения для порта VMS
	Энди Кан           (Andy Kahn)          Поддержка cscope, порт 
	                                           GTK+ GUI
	Ёзгер Кесим        (Oezguer Kesim)      Поддержка списков рассылки Vim
	Аксель Кильхорн    (Axel Kielhorn)      Работа над портом для Macintosh
	Стив Киркендал     (Steve Kirkendall)   Elvis
	Роджер Кноббе      (Roger Knobbe)       Оригинальный порт для 
	                                           Windows NT
	Сергей Ласкавый    (Sergey Laskavy)     Помощь для Vim из Москвы
	Феликс фон Лайтнер (Felix von Leitner)  Поддержка списков рассылки Vim
	Девид Леонард      (David Leonard)      Порт расширений Python для
	                                           Unix
	Авнер Лоттем       (Avner Lottem)       Редактирование в окнах справа
	                                           налево
	Флемминг Медсен    (Flemming Madsen)    Клиент-сервер для X11,
	                                           различные штучки и
						   исправления
	MicroSoft				Подарили мне копию DevStudio
	                                           для сборки Vim
	Пол Мур            (Paul Moore)         Расширения интерфейса Python,
	                                           множество исправлений
	Кацусито Нагано    (Katsuhito Nagano)   Работа над мультибайтными
	                                           версиями
        Сун Хьюн Нам       (Sung-Hyun Nam)      Работа над мультибайтными
	                                           версиями
	Винсе Негри        (Vince Negri)        Интерфейс для Win32 и общие
	                                           усовершенствования для
						   консоли
	Стив Уаллин        (Steve Oualline)     Автор первой крутой книги про
	                                           Vim |из_книги|
	Джордж В. Рейлли   (George V. Reilly)   Порт для Win32, начало работы 
	                                           для графического интерфейса 
						   Win32.
	Стефан Рим         (Stefan Roemer)      Сборщик глюков
	Ральф Шандл        (Ralf Schandl)       Порт для IBM OS/390
	Улаф Сайберт       (Olaf Seibert)       Версии для DICE и BeBox,
	                                           усовершенствования в
						   регулярных выражениях
	Мортаза Ширан      (Mortaza Shiran)     Исправления для фарси
	Петер да Сильва    (Peter da Silva)	termlib
	Пол Слутман        (Paul Slootman)      Порт для OS/2
	Генри Спенсер      (Henry Spencer)      Регулярные выражения
	Дени Сент-Амант    (Dany St-Amant)      Порт для Macintosh
	Тим Томпсон        (Tim Thompson)       Stevie
	Дж.Р.(Фред) Уолтер (G.R. (Fred) Walter) Stevie
	Свен Вердолэге     (Sven Verdoolaege)   Интерфейс для Perl
	Роберт Уэбб        (Robert Webb)        Дополнение командной строки,
	                                           версии с графическим
						   интерфейсом, множество
						   исправлений
	Инго Уилкен        (Ingo Wilken)        Интерфейс для Tcl
	Майк Уильямс       (Mike Williams)      Печать PostScript
	Юрген Вигерт       (Juergen Weigert)    Версия для Lattice version, 
						    усовершенствования для AUX, 
						    порты для UNIX и MS-DOS, 
						    autoconf
	Стефан 'Сек' Цель  (Stefan 'Sec' Zehl)	Поддержка vim.org

Я хочу поблагодарить всех людей, кто отправлял мне сообщения об ошибках и
предложения. Список был бы слишком длинным, если упомянуть всех и каждого. Vim
не был бы таким, какой он есть, если бы не идеи всех этих людей: благодаря им
Vim жив!


В документации есть несколько ссылок на другие версии Vi:
							                  *Vi*
Vi	"оригинал". Если не указано иначе, то речь идет о Vi, который появился
	впервые в Sun OS 4.x. ":version" в этой программе возвращает 
	"Version 3.7, 6/7/85". Иногда речь идет и о других версиях. Программа
	работает только под Unix. Исходный код доступен только с лицензией.
	Дополнительная информация может быть получена по адресу:
	
		http://vi-editor.org [на данный момент не работает...]

							               *Posix*
Posix	Из стандарта IEEE 1003.2, Part 2: Оболочка и утилиты.
	Широко известен как "Posix". Это текстовое описание того, как по идее
	должен работать Vi.
	Использованная версия является черновиком начала 1996, поэтому все
	замечания относятся к этому раннему тексту. Все могло измениться с тех
	пор...
							                 *Nvi*
Nvi	Новый "The New" Vi.  Версия Vi для BSD 4.4 и FreeBSD. Очень хорошая
	совместимость  с первоначальным Vi, с небольшими расширениями.
	Использовалась версия 1.79.  ":version" показывает "Version 1.79
	(10/23/96)".  За последние несколько лет не было новых выпусков
	программы, хотя в данный момент существует экспериментальная 
	версия 1.81.
	Исходный код распространяется свободно.
							               *Elvis*
Elvis	Ещё один клон Vi clone, сделанный Стивом Киркендалом. Очень
	компактный, хотя и не настолько гибкий, как Vim.
	Использовалась версия 2.1. Он до сих пор разрабатывается. Исходный код
	распространяется свободно.

==============================================================================
4. Соглашения					       *notation* *соглашения*

При использовании подсветки синтаксиса текст, который не набран буквально
часто подсвечен при помощи группы Special. Это касается элементов в скобках
[], {} и <>, и CTRL-X.

Замечание: Vim использует в командах все возможные символы. Иногда [], {} и
<> являются просто частью набора; значение как правило ясно из контекста.

[]		Символы в квадратных скобках не обязательны. 

			            *count* *[count]* *[число]* *число* *E489*
[число]		Команде может предшествовать необязательное число, которое
		указывает на повторение команды. Если число не задано, то
		используется число один, если только явно не указано что-либо
		другое. Обратите внимание, что в этом руководстве [число] не
		упоминается в описании команды, только в пояснениях. Это было
		сделано для того, чтобы было легче понять смысл команды. Если
		включена опция 'showcmd', то частично или полностью введенное
		число показывается внизу окна. Чтобы стереть последнюю цифру
		можно воспользоваться <Del> (|N<Del>|).

						       *[quotex]* *[кавычкаx]*
["x]		Необязательное указание на регистр, в котором можно хранить
		текст. См. |регистры|. x обозначает один символ от 'a' до 'z'
		или от 'A' до 'Z' или '"', и, в некоторых случаях (с командой
		put) от '0' до '9', '%', '#', и другие символы. Строчные и
		прописные буквы указывают на один регистр, но при этом
		строчная переписывает прежнее содержимое регистра, а прописная
		добавляет к прежнему содержимому новый текст. Без ""x" или
		"""" сохраненный текст размещается в безымянном регистре.

									  *{}*
{}		Фигурные скобки указывают на части команды, которые должны
		присутствовать, но могут принимать одно из нескольких
		значений. Различия между Vim и Vi также даются в фигурных
		скобках (смысл понятен из контекста).

					       *{char1-char2}* *{симв1-симв2}*
{симв1-симв2}	Один символ из диапазона от симв1 до симв2. Например: {a-z}
		обозначает строчную букву. Несколько диапазонов могут быть
		совмещены. Например, {a-zA-Z0-9} указывает на любой
		алфавитно-цифровой символ.

							       *{перемещение}*
{перемещение}	Команда, перемещающая курсор. Подробнее см. |motion.txt|.
		Примеры:

			w		к началу следующего слова
			b		к началу данного слова
			4j		на четыре строки вниз
			/Цололо<CR>	к следующему появлению слова "Цололо"

		Перемещение применяется после команда типа |оператор| чтобы
		переместиться по тексту, над которым будет совершена операция.
		- Если перемещение содержит число и оператор также содержит
		  число, то оба числа будут перемножены. Например, "2d3w"
		  стирает шесть слов.
		- Направление перемещения может быть обратным, например
		  команда "db" удаляет фрагмент текста от позиции курсора до
		  начала текущего слова.
		- Перемещение также может быть обозначено нажатием мыши. Тем
		  не менее, мышь поддерживается не всеми терминалами.
		- Команда ":omap" может быть использована для определения
		  символов в момент, когда оператор ожидает выполнения.
		- Команды Ex также могут использоваться для перемещения
		  курсора. Это можно использовать для определения функции,
		  вызывающей сложные перемещения. Перемещение всегда
		  включительно по отношению к символам, независимо от того,
		  какая команда ":" используется. Это означает, что невозможно
		  включить последний символ строки без символа перевода строки
		  (если только не включен 'virtualedit').
		  Если команда Ex изменяет текст перед тем местом, где
		  начинает работу оператор, или перемещается в другой буфер,
		  то результат непредсказуем. Возможно изменение последующего
		  текста. Перемещение в другой буфер возможно, если текущий
		  буфер при этом не выгружается.

						      *{Visual}* *{Визуально}*
{Визуально}	Отмеченная область текста. Выделение начинается с команд "v",
		"V", или CTRL-V, а затем можно использовать любую команду
		перемещения курсора для изменения точки конца выделения. 
		Используется перед командой типа |оператор| для выделения
		текста, над которым будет проводиться операция.
		См. |визуальный_режим|.

						      *<character>* *<символ>*
<символ>	Специальный символ из таблицы, приведенной ниже, возможно с
		модификаторами, или одиночный символ ASCII с модификаторами.

						      *'character'* *'символ'*
'c'		Одиночный символ ASCII.

						 *CTRL-{char}* *CTRL-{символ}*
CTRL-{симв}	{симв} набранный как управляющий; иными словами, {симв}
		набранный вместе с удерживаемой клавишей CTRL. Регистр {симв}
		не имеет значения; CTRL-A и CTRL-a эквивалентны. Однако, на
		некоторых терминалах использование кнопки SHIFT приводит к
		выдаче другого кода, в этом случае её не следует использовать.

							  *'option'* *'опция'*
'опция'		Опция или параметр, которому может быть присвоено значение,
		заключается в одиночные кавычки. См. |опции|.

				   *quotecommandquote* *кавычкакомандакавычка*
"команда"	Ссылка на команду, которую можно набрать, заключается в
		двойные кавычки.

			   *key-notation* *key-codes* *keycodes* *коды_клавиш*
Имена клавиш, указанные ниже, используются в документации. Их также можно
использовать совместно с командой ":map" (имя клавиши вставляется при помощи
CTRL-K с последующим нажатием нужной клавиши).

соглашение	значение		эквивалент	десятичное значение	~
------------------------------------------------------------------------------
<Nul>		ноль			CTRL-@	      0 (хранится 10)  *<Nul>*
<BS>		стереть слева		CTRL-H	      8		   *backspace*
<Tab>		табуляция	    	CTRL-I	      9		   *tab* *Tab*
								    *linefeed*
<NL>		протяжка строки		CTRL-J	     10   (используется вместо 
								        <Nul>)
<FF>		протяжка бумаги		CTRL-L	     12		    *formfeed*
<CR>		возврат каретки		CTRL-M	     13	     *carriage-return*
<Return>	тоже, что и <CR>				    *<Return>*
<Enter>		тоже, что и <CR>				     *<Enter>*
<Esc>		escape			CTRL-[	     27	      *escape* *<Esc>*
<Space>		пробел				     32		       *space*
<lt>		меньше чем		<	     60			*<lt>*
<Bslash>	обратная косая черта	\	     92	*backslash* *<Bslash>*
<Bar>		вертикальная черта 	|	    124		       *<Bar>*
<Del>		удалить				    127
<CSI>		начало последовательности			       *<CSI>*
		   команд (command 
		   sequence intro)	ALT-Esc 155 
<xCSI>		CSI при вводе в графическом			      *<xCSI>*
		   интерфейсе	                        

<EOL>		конец строки (в зависимости от системы		       *<EOL>*
		и установки 'fileformat' может быть 
		<CR>, <LF> или <CR><LF>)

<Up>		курсор вверх		*cursor-up* *cursor_up* *курсор_вверх*
<Down>		курсор вниз	     *cursor-down* *cursor_down* *курсор_вниз*
<Left>		курсор влево	    *cursor-left* *cursor_left* *курсор_влево*
<Right>		курсор вправо	 *cursor-right* *cursor_right* *курсор_вправо*
<S-Up>		курсор вверх с shift
<S-Down>	курсор вниз с shift
<S-Left>	курсор влево с shift
<S-Right>	курсор вправо с shift
<C-Left>	курсор влево с ctrl
<C-Right>	курсор вправо с ctrl
				                 *function_key* *function-key*
						       *функциональные_кнопки*
<F1> - <F12>	функциональные кнопки от F1 до F12 
<S-F1> - <S-F12> функциональные кнопки от F1 до F12 с shift	      *<S-F1>*
<Help>		кнопка справки
<Undo>		кнопка отмены
<Insert>	кнопка вставки
<Home>		кнопка перемещения в начало				*home*
<End>		кнопка перемещения в конец				 *end*
<PageUp>	страница вверх				   *page_up* *page-up*
<PageDown>	страница вниз			       *page_down* *page-down*
<kHome>		home на доп. клавиатуре (влево вверх)		 *keypad-home*
<kEnd>		end на доп. клавиатуре (влево вниз)		  *keypad-end*
<kPageUp>	page-up на доп. клавиатуре (вправо вверх)     *keypad-page-up*
<kPageDown>	page-down на доп. клавиатуре (вправо вниз)  *keypad-page-down*
<kPlus>		+ на доп. клавиатуре				 *keypad-plus*
<kMinus>	- на доп. клавиатуре				*keypad-minus*
<kMultiply>	* на доп. клавиатуре			     *keypad-multiply*
<kDivide>	/ на доп. клавиатуре			       *keypad-divide*
<kEnter>	Enter на доп. клавиатуре			*keypad-enter*
<kPoint>	. на доп. клавиатуре				*keypad-point*
<k0> - <k9>	цифры от 0 до 9 на доп. клавиатуре	 *keypad-0* *keypad-9*
<S-...>		shift+другая кнопка				 *shift* *<S-*
<C-...>		control+другая кнопка			*control* *ctrl* *<C-*
<M-...>		alt- или meta- и другая кнопка		    *meta* *alt* *<M-*
<A-...>		тоже, что и <M-...>					 *<A-*
<D-...>		кнопка command- (только на Macintosh)			 *<D-*
<t_xx>		кнопка за значением "xx" в termcap
------------------------------------------------------------------------------

Замечание: кнопки перемещениям курсора с shift, кнопка справки и отмены
доступны только на некоторых терминалах. На Amiga, функциональная клавиша F10
с shift выдаёт специальный код (CSI), также используемый в
последовательностях. Он будет распознаваться только после ввода следующего
символа.

Замечание: кнопка delete имеет два кода. 127 это десятичный код для кнопки
delete, который будет распознаваться всегда. В некоторых случаях кнопка delete
посылает еще один код, и в этом случае значение берется из символа termcap
"kD". Оба значения имеют одинаковый эффект. См. также |:fixdel|.

Замечание: кнопки на дополнительной клавиатуре используются также, как и их
аналоги на основной. Например, <kHome>имеет тот же эффект, что и <Home>. Если
кнопка на дополнительной клавиатуре отправляет тот же код, что и кнопка на
основной клавиатуре, то она будет распознаваться как нажатие кнопки на
основной клавиатуре. Например, если <kHome> отправляет тот же код, что и
<Home>, то при нажатии <kHome> Vim будет думать, что нажата <Home>. В этих
случаях привязка к <kHome> работать не будет.

									  *<>*
Примеры часто приводятся в угловых скобках <>. Иногда это просто указание на
то, что нужно нажать, но часто бывает так, что символы должны быть набраны
буквально, например в команде ":map". Вот правила:
 1.  Любой печатный символ набирается напрямую, за исключением обратной косой
     черты и '<'
 2.  Обратная косая черта представляется "\\", двойной обратной косой чертой
     или в виде <Bslash>.
 3.  Настоящий символ '<' представлен в виде "\<" или "<lt>". Если перепутать
     нельзя, то может использоваться и просто '<'.
 4.  "<key>" означает нажатие специальной кнопки. Соглашения объясняются в
     таблице наверху. Несколько примеров:
	    <Esc>		Кнопка Escape
	    <C-G>		CTRL-G
	    <Up>		Кнопка перемещения курсора вверх
	    <C-LeftMouse>	Нажатие левой кнопки мыши с Ctrl
	    <S-F11>		Shift+F11
	    <M-a>		Meta- a ('a' с установленным 8 битом)
	    <M-A>		Meta- A ('A' с установленным 8 битом)
	    <t_kd>		кнопка с "kd" в termcap (курсор вниз)
 
Если вы желаете использовать <> полностью в Vim, убедитесь, что флаг '<'
отсутствует в 'cpoptions' (при выключенной опции 'compatible', что является
значением по умолчанию). >
	:set cpo-=<
Соглашение <> использует <lt> для того, чтобы скрыть специальное значение
названий кнопок. Использование обратной косой черты также будет работать, но
только в том случае, если 'cpoptions' не включает флага 'B'.

Примеры установки соответствия CTRL-H и слова "<Home>": >
	:imap <C-H> \<Home>
	:imap <C-H> <lt>Home>
Первый пример работает только если в 'cpoptions' нет флага 'B'. Второй пример
работает всегда.
Чтобы получить буквальное значение "<lt>" в привязке: >
	:map <C-L> <lt>lt>

Для привязок кнопок, сокращений и команд меню вы можете копировать-вставлять
примеры и использовать их напрямую. Либо, вы можете набирать их буквально как
они есть, включая символы '<' и '>'. Это не будет работать для других команд,
таких как ":set" и ":autocmd"!

==============================================================================
5. Введение в режимы Vim	    *vim-modes-intro* *vim-modes* *режимы_vim*

В Vim есть шесть ОСНОВНЫХ режимов:

		         *Normal* *Normal-mode* *command-mode* *обычный_режим*
Обычный режим		В Обычном режиме вы можете вводить все обычные команды
			редактора. Вы оказываетесь в этом режиме после запуска
			редактора (если только не установлена опция
			'insertmode', см. ниже). Также известен как нормальный
			или командный режим.

Визуальный режим	Этот режим напоминает Обычный режим, но команды
			перемещения курсора изменяют область выделения. Если
			используется команда, не являющаяся командой
			перемещения, то она применяется к выделенной таким
			образом области. См. |визуальный_режим|.
			При включенной опции 'showmode' в этом режиме внизу
			экрана появляется надпись "-- ВИЗУАЛЬНЫЙ РЕЖИМ --".

Режим выделения		Этот режим похож на режим выделения MS-Windows.
			Набор печатного символа удаляет выделенный текст и
			переводит редактор в режим вставки. См.
			|режим_выделения|.
			При включенной опции 'showmode' в этом режиме внизу
			экрана появляется надпись "-- ВЫДЕЛЕНИЕ --".

Режим вставки		В режиме вставки набранный вами текст вставляется в
			буфер. См. |режим_вставки|.
			При включенной опции 'showmode' в этом режиме внизу
			экрана появляется надпись "-- ВСТАВКА --".

Режим командной строки	В режиме командной строки вы можете вводить текст в
			строке внизу экрана. Этот режим существует для команд
			Ex, команд ":", команд поиска по шаблону, "?" и "/", а
			также команды фильтра, "!".  |режим_командной_строки|
			
Режим Ex		То же, что режим командной строки, но после выполнения
			команды вы остаётесь в этом режиме. Доступно весьма
			ограниченное редактирование командной строки.  
			|режим_Ex|

Также существует пять ДОПОЛНИТЕЛЬНЫХ режимов. Все они являются вариантами
ОСНОВНЫХ режимов.

				    *Operator-pending* *Operator-pending-mode*
						    *режим_ожидания_оператора*
Режим ожидания оператора
			То же, что и обычный режим, но после начала команды
			оператора, когда Vim ожидает {перемещения}, чтобы
			указать текст, над которым будет выполняться команда
			оператора. 

Режим замены		Режим замены является особым случаем режима вставки.
			Отличие заключается в том, что текст, который вы
			будете набирать, будет заменять текст, который вы
			набирали перед этим, а не вставлять новый текст перед
			ним. См. |режим_замены|.
			При включенной опции 'showmode' в этом режиме внизу
			экрана появляется надпись "-- ЗАМЕНА --".
			
Обычный режим в 
режиме вставки
			Vim переходит в этот режим при нажатии CTRL-O в режиме
			вставки. При этом, Vim начинает вести себя как если бы
			он был в обычном режиме, но после выполнения команды
			возвращается в режим вставки.
			При включенной опции 'showmode' в этом режиме внизу
			экрана появляется надпись "-- (вставка) --".

Визуальный режим в 
режиме вставки
			Vim переходит в этот режим при переходе к визуальному
			режиму из режима вставки, например при использовании
			CTRL-O и последующей команды "v", "V" или CTRL-V.
			Когда визуальный режим завершается, то Vim переходит в
			режим вставки.
			При включенной опции 'showmode' в этом режиме внизу
			экрана появляется надпись "-- (вставка) ВИЗУАЛ. --".
Режим выделения в
режиме вставки
			Vim переходит в этот режим при переходе к режиму
			выделения из режима вставки, например при
			использовании мыши или <S-Right>. 
			После окончания режима выделения Vim переходит в режим
			вставки.
			При включенной опции 'showmode' в этом режиме внизу
			экрана появляется надпись "-- (вставка) ВЫДЕЛЕНИЕ --".

==============================================================================
			                                      *mode-switching*
6. Переключение между режимами	                        *переключение_режимов*

Если вы по какой-либо причине не знаете в каком режиме находитесь в данный
момент, то вы всегда можете вернуться в обычный режим, если дважды нажмёте
<Esc>, за исключением режима Ex, в котором вам придётся использовать команду
":visual".
При переходе в обычный режим после нажатия <Esc> экран моргнёт или вы услышите
сигнал. В то же время, после нажатия <Esc> при использовании в режиме вставки
CTRL-O вы также услышите сигнал, но по прежнему будете находиться в режиме
вставки, поэтому вам потребуется набрать <Esc> еще раз. 

								       *i_esc*
		В режим 						    ~
		Обычный	Визуал.	Выдел.	Вставка	  Замена   Команд.    Ex ~
ИЗ режима 								 ~
Обычный			v V ^V	  *4	 *1	    R	    : / ? !   Q
Визуал.		 *2		  ^G	 c C	    --	      :       --
Выдел.		 *5	^O ^G		 *6	    --	      --      --
Вставка		 <Esc>	  --	  --		  <Insert>    --      --
Замена 		 <Esc>	  --	  --	<Insert>	      --      --
Команд. строка	 *3	  --	  --	 :start	    --		      --
Ex		 :vi	  --	  --	 --	    --	      --

-  не доступно
-- не возможно

*1 Из Обычного режима в режим Вставки можно перейти при помощи команд "i",
   "I", "a", "A", "o", "O", "c", "C", "s" или "S".
*2 Из Визуального в Обычный режим можно перейти при помощи команды, не
   являющейся командой перемещения, при этом команда будет выполнена, или при
   помощи <Esc> "v", "V" или "CTRL-V" (см. |v_v|), что приводит просто к
   остановке Визуального режима без каких-либо последствий.
*3 Из режима Командной строки к Обычному режиму можно перейти следующим
   образом:
   - По нажатию <CR> или <NL>, что приводит к выполнению введенной команды.
   - При уничтожении всей командной строки (например, при помощи CTRL-U) и
     введении завершающего <BS>.
   - По нажатию CTRL-C или <Esc>, что приводит к завершению режима командной
     строки без выполнения команды.
   В последнем случае <Esc> может быть также символом, определенным с помощью
   опции 'wildchar'; в этом случае будет отработано автодополнение командной
   строки. Автодополнение можно проигнорировать и повторно нажать <Esc>. {Vi:
   при нажатии <Esc> командная строка выполняется. Для большинства людей такое
   поведение является неожиданным, поэтому оно было изменено в Vim. Однако,
   если <Esc> является частью команды привязки, то командная строка будет
   выполнена. Если вы хотите, чтобы Vim вёл себя как Vi при отработке <Esc>,
   то используйте ":cmap ^V<Esc> ^V^M"}
*4 Переход из Обычного режима в режим Выделения выполняется следующим образом:
   - при помощи выделения текста мышью, если 'selectmode' содержит "mouse"
   - при помощи непечатной команды для перемещения курсора в комбинации с
     нажатым Shift, если 'selectmode' содержит "key"
   - при помощи "v", "V" или "CTRL-V", если 'selectmode' содержит "cmd"
   - при помощи "gh", "gH" или "g CTRL-H"  |g_CTRL-H|
*5 Переход из режима Выделения в Обычный режим выполняется при помощи
   непечатной команды для перемещения курсора без нажатой клавиши Shift.
*6 Переход из режима Выделения в режим Вставки выполняется при помощи набора
   печатного символа. Выделение при этом удаляется и осуществляется вставка
   набранного символа.

Если включена опция 'insertmode', то редактирование файла начинается в режиме
Вставки.
   
	 *CTRL-\_CTRL-N* *i_CTRL-\_CTRL-N* *c_CTRL-\_CTRL-N* *v_CTRL-\_CTRL-N*
Дополнительно можно использовать команды CTRL-\ CTRL-N или <C-\><C-N> для
перехода в Обычный режим из любого другого режима. Это можно использовать для
того, чтобы быть уверенным в том, что Vim перешел в Обычный режим. При этом
звуковой сигнал, как в случае с <Esc>, не подаётся. Однако, этот метод не
работает в режиме Ex. При использовании после команды, которая принимает
параметр, такой как |f| или |m|, применяется временной интервал ожидания,
который задаётся с помощью опции 'ttimeoutlen'.

	 *CTRL-\_CTRL-G* *i_CTRL-\_CTRL-G* *c_CTRL-\_CTRL-G* *v_CTRL-\_CTRL-G*
Команда CTRL-\ CTRL-G или <C-\><C-G> может использоваться для перехода в режим
Вставки при включённой опции 'insertmode'. При выключенной опции эта команда
осуществляет переход в Обычный режим. Это обстоятельство может использоваться
для быстрого перехода в режим, указанный в опции 'insertmode', без
необходимости знать в каком режиме Vim находится в данный момент.

		           *Q* *mode-Ex* *Ex-mode* *Ex* *EX* *режим_Ex* *E501*
Q			Переход в режим "Ex". Этот режим напоминает набор
			команд ":" со следующими отличиями:
			- Вы не должны набирать ":".
			- Экран не обновляется после каждой команды.
			- Нормальное редактирование командной строки отсутствует.
			- Привязки и сокращения не работают.
			Фактически, вы редактируете строки при помощи
			"стандартных" средств ввода строки (<Del> или <BS> для
			стирания символов, CTRL-U для уничтожения всей
			строки).
			Vim переходит в этот режим по умолчанию, если
			вызывается с командной строки как "ex".
			Для выхода из режима "Ex" пользуйтесь командой ":vi"
			|:visual|. Замечание: В старых версиях Vim "Q"
			использовалось для форматирования текста, теперь эта
			операция выполняется с |gq|. Однако, если вы
			используете сценарий |vimrc_example.vim|, то "Q"
			работает как "gq".
			
									  *gQ*
gQ			Переход в режим "Ex", но при этом поведение редактора
			остаётся таким же, как если бы ":" команды отдавались
			одна за другой. Доступны все функции автодополнения,
			редактирования командной строки и т.д.
			Для выхода из режима "Ex" используйте команду ":vi".
			{Vi не имеет этой функции}

==============================================================================
7. Содержимое окна					     *содержимое_окна*

В Обычном режиме и в режима Вставки/Замены в окне будет отображаться текущее
содержимое буфера: Вы Видите То, Что Есть. Существует два исключения:
- Если опция 'cpoptions' содержит '$', и изменения затрагивают одну строку, то
  текст не удаляется мгновенно, но на месте последнего удаленного символа
  помещается '$'.
- При изменении текста в одном окне, другие окна, содержащие тот же самый
  текст не будут обновляться до тех пор, пока не завершен режим Вставки.
{Vi: Экран не всегда обновляется на медленных терминалах}

Строки, которые длиннее чем ширина окна, будут переноситься, если только не
отключена опция 'wrap' (см. ниже). Опция 'linebreak' может быть установлена
таким образом, чтобы перенос происходил на пустом символе.

Если в окне остаётся место после последней строки, то Vim будет показывать '~'
в первой колонке последних строк окна, например так: >

	+-----------------------+
	|строка                 |
	|последняя строка       |
	|~                      |
	|~                      |
	+-----------------------+

Таким образом, строки, начинающиеся с '~', указывают на конец буфера.

Если последняя строка в экране не умещается, то Vim будет указывать на это с
помощью символа '@' в первой колонке последних строк окна, например так: >

	+-----------------------+
	|первая строка          |
	|вторая строка          |
	|@                      |
	|@                      |
	+-----------------------+

Таким образом, строки, начинающиеся с '@', указывают, что строка не умещается
в окне целиком.

Если в опции 'display' присутствует флаг "lastline", то вы не увидите символов
'@' в левой части окна. Если последняя строка не умещается в окне полностью,
то показывается та часть строки, которая умещается в экране, а последние
три символа меняются на "@@@", например: >

	+-----------------------+
	|первая строка          |
	|вторая строка          |
	|очень длинная строка, к|
	|оторая не умещается @@@|
	+-----------------------+

Если есть одна единственная строка, которая тем не менее слишком длинна, чтобы
уместится в окне, то возникает особая ситуация. Vim будет показывать ту часть
строки, на которую указывает курсор. При этом никаких специальных символов
показано не будет, чтобы вы могли редактировать все части строки.
{Vi: при попытке редактирования строк, не умещающихся в окне, происходит
"внутренняя ошибка"}

Опция 'highlight' позволяет указывать '@' для использования специальной
подсветки символов '@' и '~'. Это позволяет отличать их от "настоящих"
символов в буфере.

Опция 'showbreak' содержит строку, которая должна размещаться перед
перенесенными строками. 

					      *wrap-off* *отключение_переноса*
Если опция 'wrap' отключена, то длинные строки переноситься не будут. На
экране будет показана только та часть строки, которая убирается в ширину
экрана. Если курсор перемещается к непоказанной части строки, то экран
прокручивается по горизонтали. Преимущества этого метода в том, что колонки
показаны так как есть и можно редактировать строки, которые не убираются на
экране. Минус заключается в том, что вы не можете видеть все символы строки
сразу. Опция 'sidescroll' позволяет указать минимальное количество колонок для
прокрутки. {Vi: опция 'wrap' отсутствует}

Все обычные символы ASCII отображаются на экране напрямую. <Tab> заменяется
пробелами в требуемом количестве. Другие непечатные символы заменяются
"^{символ}", где {символ} это непечатный символ плюс 64. Таким образом, 7
(bell) будет показан как "^G". Символы между 127 и 160 заменяются
"~{символ}", где {символ} это символ минус 64. Такие символы занимают на
экране больше одной позиции, курсор может быть подведен только к первой
позиции.

При помощи опции 'number' все строки на экране будут предваряться порядковым
номером. Совет: Если вам не хочется, чтобы перенесенные строки мешались с
номерами строк, установите опцию 'showbreak' в 8 пробелов:
	":set showbreak=\ \ \ \ \ \ \ \ "

Опция 'list' позволяет показывать символы <Tab> как "^I" вместо нескольких
пробелов. В этом случае в конце строки также будет помещен символ '$', чтобы
вы могли видеть лишние пробелы на конце строки.

В режиме командной строки корректно отображается только сама командная строка.
Содержимое буфера будет обновлено как только вы вернетесь в Обычный режим.

Последняя строка экрана используется для сообщений и отображения состояния.
Сообщения о состоянии будут использоваться только в следующих случаях:

сообщение состояния	    	опция	        по умолч.   по умолч. Unix	~
текущий режим			'showmode'	on	    on
символы команды   		'showcmd'	on	    off
позиция курсора			'ruler'		off	    off

Под текущим режимом подразумевается "-- ВСТАВКА --" или "-- ЗАМЕНА --", см.
|'showmode'|. Символы команды это те символы, которые уже набраны, но пока не
использованы. {Vi: набранные символы или позиция курсора не отображается}

На медленных терминалах можно выключить статусные сообщения для ускорения
редактирования:
	:set nosc noru nosm

При возникновении ошибок, сообщение об ошибке будет показано не менее одной
секунды (в инверсном видеорежиме). {Vi: сообщения об ошибках могут быть
перезаписаны другими сообщениями до того, как вы сможете прочитать их}

Некоторые команды показывают сколько именно строк было затронуто. Порог, при
котором это отражается, может быть установлен опцией 'report' (по умолчанию 2).

На Amiga Vim выполняется в окне CLI. В заголовке окна отражается название Vim
и полное имя текущего файла. При изменении размеров окна Vim автоматически
обновляет его. Вы можете сделать окно таким маленьким, каким пожелаете, но
если оно окажется слишком маленьким, то в нём может не убираться ни одна
строка. Пусть ваше окно будет хотя бы 40 символов в ширину, чтобы у вас была
возможность читать большинство сообщений на последней строке. 

На большинстве систем Unix изменение размера окна также распознается и правильно
отрабатывается. {Vi: с этим есть проблемы}

==============================================================================
8. Определения					   *definitions* *определения*

  экран			Полная область, в которой работает Vim. Это может быть
			окно эмулятора терминала. Часто также называется "окно
			Vim".
  окно			Вид буфера.

Экран состоит из одного или нескольких окон, разделенных строками состояния и
командной строки в самом низу экрана.

	+-----------------------------------------+
экран 	| окно 1  	     | окно 2  	          |
	|		     |		          |
	|		     |	 	          |
	|= строка состояния =|= строка состояния =|
	| окно 3                	          |
	|				          |
	|				          |
	|==== строка состояния ===================|
	|командная строка   			  |
	+-----------------------------------------+

Командная строка также используется для сообщений. Если для командной строки
недостаточно места, то экран прокручивается.

Существует четыре различных типа строк:

  строки буфера		Строки в буфере. Это то же самое, что и строки,
			которые можно прочитать из файла или записать в файл.
			Они могут быть тысячи символов в длину.
  логические строки	Строки буфера, находящиеся в складках. Строки буфера в
			закрытой складке заменяются на одну логическую строку:
			"+-- 99 строк в складке". Они могут быть тысячи
			символов в длину.
  строки окна		Строки, отражаемые в окне: это логические строки, к
			которым применяется перенос, разбивка строк и т.д. Они
			не могут быть длиннее, чем позволяет ширина окна,
			строки, которые длиннее переносятся или обрезаются.
  строки экрана		Это строки экрана, который используется Vim. К ним
			относятся строки окна всех окон, вместе со всеми
			статусными строками и командной строкой. Строки экрана
			не могут быть длиннее, чем позволяет ширина экрана.
			Если командная строка становится длиннее, то она
			переносится, а строки прокручиваются, чтобы выделить
			место под командную строку.
  
строки буфера	логические строки   строки окна		строки экрана ~

1. один		1. один		    1. +-- в складке	1.  +-- в складке
2. два		2. +-- в складке    2. пять		2.  пять
3. три  	3. пять		    3. шесть		3.  шесть
4. четыре   	4. шесть    	    4. семь		4.  семь
5. пять		5. семь					5.  === стр. сост. ===
6. шесть						6.  ааа
7. семь							7.  ббб
							8.  ввв ввв в
1. ааа		1. ааа		    1. ааа		9.  вв
2. ббб		2. ббб		    2. ббб		10. ггг
3. ввв ввв ввв	3. ввв ввв ввв	    3. ввв ввв в	11. ~ 
4. ггг		4. ггг		    4. вв		12. === стр. сост. ===
				    5. ггг		13. (командная строка)
				    6. ~ 

==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
