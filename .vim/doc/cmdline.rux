*cmdline.txt*   Для Vim version 6.3.  Последнее изменение: 2004 Mar 31


		      СПРАВОЧНИК ПО VIM - Брам Мооленаар

				            *Cmdline-mode* *Command-line-mode*
		                   *Cmdline* *Command-line* *mode-cmdline* *:*
Режим командной строки		   *режим_командной_строки* *командная_строка*

Режим командной строки используется для ввода команд Ex (":"), шаблонов для
поиска ("/" и "?") и команд-фильтров ("!").

Основы редактирования командной строки излагаются в главе 20 Руководства
Пользователя |usr_20.txt|.

1. Редактирование командной строки	|командная_строка-редактирование|
2. Автодополнение командной строки      |командная_строка-автодополнение|
3. Командные строки Ex			|командная_строка-строки|
4. Диапазоны в командной строке Ex      |командная_строка-диапазоны|
5. Специальные символы Ex		|командная_строка-спецсимволы|
6. Окно командной строки                |командная_строка-окно|

==============================================================================
							     *cmdline-editing*
1. Редактирование командной строки	     *командная_строка-редактирование*

Символы обычно вставляются в позиции перед курсором. Вы можете перемещаться
в командной строке при помощи кнопок горизонтального управления курсором.
Кнопка <Insert> позволяет переключаться между режимами вставки и замены
символов.
{Vi: можно изменять только последний символ в строке}

Обратите внимание, что если на вашей клавиатуре отсутствуют клавиши управления
курсором или другие специальные кнопки, то можно переназначить их действие на
любую другую кнопку при помощи команды ":cnoremap".
Например, для определения кнопок редактирования командной строки в стиле
tcsh можно использовать следующую серию команд:      
						     *tcsh-style* *стиль-tcsh*
>
	:cnoremap <C-A> <Home>
	:cnoremap <C-F> <Right>
	:cnoremap <C-B> <Left>
	:cnoremap <Esc>b <S-Left>
	:cnoremap <Esc>f <S-Right>

(используется соглашение <> |<>|; команды набираются буквально).

		         *cmdline-too-long* *командная_строка-слишком_длинная*
Когда командная строка становится слишком длинной, чтобы поместиться по ширине
экрана, то будет показана только часть введённой командной строки. В этом
случае редактированию подлежит только видимая часть командной строки,
поскольку курсор может перемещаться только в видимой части.

						   *cmdline-history* *history*
	       *история_командной_строки* *командная_строка-история* *история*
Строки команд, которые вы вводите, запоминаются в таблице истории. Кнопки
вертикального перемещения курсора позволяют перемещаться между разными
строками в этой таблице. Вообще-то существует не одна, а целых четыре
отдельных таблицы истории:

- для команд ':'
- для строк поиска
- для выражений
- для строк ввода, которые набираются при выполнении функции |input()|.

Эти таблицы полностью независимы друг от друга. Каждая таблица становится
доступна только при вводе строки соответствующего типа.
Опция 'history' позволяет задавать количество строк, которые должны храниться
в таблице (по умолчанию: 20).

Замечания:

- При вводе командной строки, которая полностью идентична уже сохранённой
  строке, старая строка удаляется из истории (чтобы избежать вытеснения
  старых команд повторяющимися командами).
- В истории сохраняются только те команды, которые набираются на клавиатуре.
  Команды, которые выполняются при отработке привязок, в историю не попадают.
- Все строки поиска попадают в историю поиска, включая те, которые являются
  результатом выполнения команд "*" и "#". Однако, при использовании привязки
  запоминается только последняя строка поиска (чтобы длинные команды-привязки
  не засоряли историю).
  
{Vi не имеет истории}
{доступно только в том случае, если Vim скомпилирован с особенностью
|+cmdline_hist|}

В командной строке также доступно автодополнение различных имён; подробнее см.
в разделе |дополнение_командной_строки|.

							            *c_CTRL-V*
CTRL-V		Буквальная вставка следующего нецифрового символа. При вводе
		до трёх цифр, они рассматриваются как десятичное значение
		одиночного байта. При вводе нецифрового символа и последующем
		вводе цифр, цифры воспринимаются как обычные символы. По
		существу, это работает точно так же, как и в режиме Вставки
		(см. раздел |i_CTRL-V|).
		Замечание: В системе Windows CTRL-V часто используется для
		вклейки текста. В этом случае следует использовать CTRL-Q.
		
							            *c_CTRL-Q*
CTRL-Q		То же, что и CTRL-V, однако этот вариант не работает на тех
		терминалах, где данный символ используется для управления
		потоком. 

							            *c_<Left>*
<Left>		перемещение курсора влево

							           *c_<Right>*
<Right>		перемещение курсора вправо
							          *c_<S-Left>*
<S-Left> или <C-Left>					          *c_<C-Left>*
		перемещение курсора на одно СЛОВО влево
							         *c_<S-Right>*
<S-Right> или <C-Right>					         *c_<C-Right>*
		перемещение курсора на одно СЛОВО вправо
		
CTRL-B или <Home>					 *c_CTRL-B* *c_<Home>*
		перемещение курсора в начало командной строки
		
CTRL-E или <End>					  *c_CTRL-E* *c_<End>*
		перемещение курсора в конец командной строки

					 *c_<LeftMouse>* *c_<ЛеваяКнопкаМыши>*
<LeftMouse>
<ЛеваяКнопкаМыши>	
		перемещение курсора в позицию щелчка левой кнопки мыши

CTRL-H							   *c_<BS>* *c_CTRL-H*
<BS>		удаление символа перед курсором (см. |:fixdel|, если кнопка
		<BS> в вашей системе работает не так, как требуется)

							             *c_<Del>*
<Del>		удаление символа в позиции курсора (в конце строки: символа
		перед курсором) (см. |:fixdel|, если кнопка <Del> в вашей
		системе работает не так, как требуется)

							            *c_CTRL-W*
CTRL-W		удаление слова перед курсором

							            *c_CTRL-U*
CTRL-U		удаление всех символов между началом строки и позицией
		курсора. Предыдущие версии Vim выполняли по этой команде 
		удаление всех символов в строке. Если вам больше нравится
		такое поведение, то добавьте в сценарий .vimrc следующую
		строку: >

			:cnoremap <C-U> <C-E><C-U>
<
		Замечание: если командная строка опустошается при
		использовании одной из команд удаления, то происходит выход из
		режима командной строки.

							          *c_<Insert>*
<Insert>	Переключение между вставкой и заменой символов.
		{Vi не имеет такой возможности}

{симв1} <BS> {симв2}	или			        *c_digraph* *c_диграф*
CTRL-K {симв1} {симв2}						    *c_CTRL-K*
		ввод диграфа (см. |диграфы|). Если {симв1} является
		специальной кнопкой, то вставляется код этой кнопки 
		в формате <>.
		{Vi не имеет такой возможности}

CTRL-R {0-9a-z"%#:-=.}					  *c_CTRL-R* *c_<C-R>*
		Вставка содержимого нумерованного или именованного регистра.
		Между вводом CTRL-R и вторым символом отображается символ '"',
		который указывает, что требуется ввести имя регистра.

		Текст вставляется в точности так, как если бы вы ввели его с
		клавиатуры, но при этом привязки и сокращения не используются.
		Также не используется дополнение командной строки при вводе
		символf 'wildchar'. Символы, которые при вводе с клавиатуры
		приводят к прекращению режима командной строки, в этом случае
		вставляются буквально (<Esc>, <CR>, <NL>, <C-C>). В то же
		время, символы <BS> и CTRL-W по прежнему могут приводить к
		выходу из режима командной строки, причём оставшиеся в
		регистре символы будут интерпретироваться уже в другом режиме,
		что, возможно, не является желательным.

		Специальные регистры:
		
			'"'	безымянный регистр, содержащий удалённый или
				скопированный в последний раз текст
			'%'	имя текущего файла
			'#'	имя соседнего файла
			'*'	содержимое буфера обмена (X11: основное
			        выделение)
			'+'     содержимое буфера обмена
			'/'	последний из использованных шаблонов поиска
			':'	последняя введённая командная строка
			'-'	последнее небольшое (меньше строки) удаление
			'.'	последний вставленный текст
			                                          *c_CTRL-R_=*
			'='	регистр выражений: от вас требуется ввести
				выражение (см. |выражение|).

		Подробнее о регистрах см. раздел |регистры|.
		{Vi не имеет такой возможности}

CTRL-R CTRL-F				     *c_CTRL-R_CTRL-F* *c_<C-R>_<C-F>*
CTRL-R CTRL-P				     *c_CTRL-R_CTRL-P* *c_<C-R>_<C-P>*
CTRL-R CTRL-W				     *c_CTRL-R_CTRL-W* *c_<C-R>_<C-W>*
CTRL-R CTRL-A				     *c_CTRL-R_CTRL-A* *c_<C-R>_<C-A>*

		Вставка объекта, расположенного в позиции курсора в буфере:
		
			CTRL-F	Имя файла в позиции курсора
			CTRL-P	Имя файла в позиции курсора, с указанием пути
				'path', как при использовании команды |gf|
			CTRL-W	Слово в позиции курсора
			CTRL-A	СЛОВО в позиции курсора; см. |СЛОВО|

		{Vi не имеет такой возможности}
		
		CTRL-F и CTRL-P: {доступно только при включённой особенности 
		+file_in_path}

					     *c_CTRL-R_CTRL-R* *c_<C-R>_<C-R>*
					     *c_CTRL-R_CTRL-O* *c_<C-R>_<C-O>*
CTRL-R CTRL-R {0-9a-z"%#:-=. CTRL-F CTRL-P CTRL-W CTRL-A}
CTRL-R CTRL-O {0-9a-z"%#:-=. CTRL-F CTRL-P CTRL-W CTRL-A}
		Вставка регистра или объекта, расположенного в позиции курсора
		в буфере. Работает так же, как и |c_CTRL-R|, но текст
		вставляется буквально. Например, если регистр a содержит
		"xy^Hz"	(где ^H это символ удаления предыдущего символа), то
		команда "CTRL-R a" приводит к вставке "xz", а команда "CTRL-R
		CTRL-R a" приводит к вставке "xy^Hz".

CTRL-\ e {выражение}                                              *c_CTRL-\_e*
		Вычислить указанное {выражение} и заменить всю командную
		строку полученным результатом. При вводе этой команды
		появляется приглашение для ввода выражения, которое
		завершается по нажатию <Enter>. Команда наиболее полезна в
		привязках. См. |выражение|.
                См. также команду |c_CTRL-R_=|, которая выполняет вставку
		результата вычисления выражения. Полезными функциями являются
		|getcmdline()| и |getcmdpos()|. Позиция курсора не изменяется,
		кроме случая, когда курсор находится в конце строки -- в этом
		случае курсор остаётся в конце строке.
		Функция |setcmdpos()| может использоваться для настройки
		позиции курсора.

		Пример: 
>
                    :cmap <F7> <C-\>eAppendSome()<CR>
	            :func AppendSome()
	            :let cmd = getcmdline() . " Some()"
	            :" place the cursor on the )
	            :call setcmdpos(strlen(cmd))
	            :return cmd
		    :endfunc
<
                                                                    *c_CTRL-Y*
CTRL-Y		При наличии безрежимного выделения, скопировать выделенный
		текст в буфер обмена; см. |безрежимное_выделение|.
		Если выделение отсутствует, то в командную строку вставляется
		символ CTRL-Y.

CTRL-J						  *c_CTRL-J* *c_<NL>* *c_<CR>*
<CR> или <NL>	приступить к выполнению введённой команды.

							             *c_<Esc>*
<Esc>		Если в опции 'cpoptions' не указан флаг 'x', то при вводе с
		клавиатуры выполняется выход из режима командной строки. При
		отработке макроса или если в опции 'cpoptions' указан флаг
		'x', начинается выполнение введённой команды.

							            *c_CTRL-C*
CTRL-C		выход из режима командной строки без выполнения введённой
		команды.

							              *c_<Up>*
<Up>		восстановить предыдущую команду, начинающуюся с символов уже
		введённых в командной строке, из истории (см. ниже).
		{доступно только в том случае, если Vim скомпилирован с
		особенностью |+cmdline_hist|}

							            *c_<Down>*
<Down>		восстановить следующую команду, начинающуюся с символов уже
		введённых в командной строке, из истории (см. ниже).
		{доступно только в том случае, если Vim скомпилирован с
		особенностью |+cmdline_hist|}

						       *c_<S-Up>* *c_<PageUp>*
<S-Up> или <PageUp>
		восстановить предыдущую команду из истории
		{доступно только в том случае, если Vim скомпилирован с
		особенностью |+cmdline_hist|}
		
						   *c_<S-Down>* *c_<PageDown>*
<S-Down> или <PageDown>
		восстановить следующую команду из истории
		{доступно только в том случае, если Vim скомпилирован с
		особенностью |+cmdline_hist|}

CTRL-D		дополнение командной строки 
		(см. |командная_строка-автодополнение|)
		
значение опции 'wildchar'
		дополнение командной строки 
		(см. |командная_строка-автодополнение|)

CTRL-N		дополнение командной строки 
		(см. |командная_строка-автодополнение|)
CTRL-P		дополнение командной строки 
		(см. |командная_строка-автодополнение|)
CTRL-A		дополнение командной строки 
		(см. |командная_строка-автодополнение|)
CTRL-L		дополнение командной строки 
		(см. |командная_строка-автодополнение|)

							            *c_CTRL-_*
CTRL-_		a - переключение между режимами клавиатуры "иврит" и
		"английский", без использования hkmap. Эта команда выполняет
		переключение только в командной строке. Она может быть полезна
		в тех случаях, когда требуется ввод текста на иврите в
		командной строке, в строке поиска, в сокращениях и т.п. Она
		применима только в том случае, если Vim скомпилирован с
		особенностью |+rightleft| и при включённой опции
		'allowrevins'.
		См. |rileft.txt|.

		b - переключение между режимами клавиатуры "фарси" и
		"английский", без использования fkmap. Эта команда выполняет
		переключение только в командной строке. В режиме фарси символы
		вставляются в обратном порядке. Она может быть полезна
		в тех случаях, когда требуется ввод текста на фарси в
		командной строке, в строке поиска, в сокращениях и т.п. Она
		применима только в том случае, если Vim скомпилирован с
		особенностью |+farsi|.
		См. |farsi.txt|.

							            *c_CTRL-^*
CTRL-^		Переключение между языковыми раскладками |:lmap| и/или
		использованием различных Методов Ввода.
		При вводе шаблона для команды поиска значение VAL принимается
		равным значению опции 'iminsert', либо равным значению
		'imsearch', если значение опции 'imsearch' не равно -1.
		
		Если определёны языковые раскладки, то

		- при VAL равном 1 (включённом использовании языковых
		  раскладок), VAL становится равным 0 (языковые раскладки не
		  используются).
		- при VAL не равном 1, VAL становится равным 1, что приводит к
		  включению языковых раскладок.

		Если языковые раскладки не определены:

		- при VAL равном 2 (включённом использовании Метода Ввода),
		  VAL становится равным 0 (Метод Ввода не используется).
		- при VAL не равном 2, VAL становится равным 2, что приводит к
		  использованию Метода Ввода.

		Языковые раскладки обычно используются для ввода символов,
		отличных от тех, которые вводятся с клавиатуры. Для
		определения набора языковых раскладок используется опция
		'keymap'. При вводе командной строки языковые раскладки
		отключаются, поскольку предполагается, что вы приступаете к
		вводу команды. После включения раскладок по команде
		CTRL-^ новое состояние не будет использоваться для последующих
		команд или при вводе шаблона для поиска.
		{Vi не имеет такой возможности}

О редактировании командной строки в стиле Emacs читайте в разделе
|кнопки-emacs|.

Кнопки <Up> и <Down> используют текущую командную строку в качестве строки для
поиска в истории команд. Начало следующей или предыдущей строки в истории
сравнивается с текущей командной строкой. Новой командной строкой становится
первая же строка, которая соответствует введённой строке. При повторном вводе
той же самой кнопки используется та же самая строка. Например, эта возможность
может быть использована для поиска предыдущей команды замены: достаточно
ввести ":s" и затем нажать кнопку <Up>. То же самое может быть выполнено и при
помощи ввода <S-Up> необходимое количество раз, до тех пор, пока не появится
нужная командная строка. (Замечание: кнопки управления курсором с одновременно
нажатой кнопкой <Shift> работают не на всех терминалах).

							      *his* *:history*
:his[tory]	Выводит историю последних введённых команд.
		{Vi не имеет такой возможности}
		{доступно только в том случае, если Vim скомпилирован с
		особенностью |+cmdline_hist|}

:his[tory] [{имя}] [{первое}][, [{последнее}]]
		Показать историю с указанным {именем}, которое может иметь
		одно из следующих значений:
		
		c[md]	 или :	история командной строки
		s[earch] или /	история строки поиска
		e[xpr]	 или =	история регистра выражений
		i[nput]	 или @	история строки ввода
		a[ll]		все вышеперечисленные
		{Vi не имеет такой возможности}

		В том случае, если заданы числа {первое} и/или {последнее},
		будет показан соответствующий диапазон строк истории. Эти
		числа могут быть заданы в одной из следующих форм:
		
				     *:history-indexing* *:history-индексация*
		Положительное число указывает на абсолютный номер строки в
		истории, который указан в первой колонке вывода команды
		:history. Это число остаётся неизменным даже в том случае,
		если какие-либо строки будут удалены из истории.

		Отрицательное число указывает на положение строки относительно
		самой последней строки в истории (которая имеет индекс, равный
		-1), от более поздних к более ранним.
		
		Примеры:

		Показать строки от 6 до 12 из истории поиска: >

			:history / 6,12
<
		Показать последние пять строк из всех историй: >

			:history all -5,

==============================================================================
                                                          *cmdline-completion* 
						 *дополнение_командной_строки*
2. Автодополнение командной строки           *командная_строка-автодополнение*

При редактировании командной строки доступно несколько команд, позволяющих
дополнять слово, набранное непосредственно перед курсором. Эти команды
позволяют выполнять следующие виды дополнений:

- Имена команд: в начале командной строки.
- Метки: только после команды ":tag".
- Имена файлов: только после команд, которые позволяют указывать имя файла или
  в настройках опции, которые позволяют использовать в качестве значения имя
  файла.
- Опции: только после ввода команды ":set".
- Привязки: только после команды ":map" и ей подобных.
- Переменные и имена функций: только после команд ":if", ":call" и им
  подобных.

Если Vim был скомпилирован с отключённой особенностью |+cmdline_compl|, то
дополнение возможно только для имён файлов, каталогов и разделов справочника.

Для дополнения используются следующие команды:

							            *c_CTRL-D*
CTRL-D		Показать список имён, соответствующих шаблону перед курсором.
		При отображении имён файлов каталоги выделяются цветом (см.
		справку по опции 'highlight'). Имена, в которых расширение
		соответствует значениям, перечисленным в опции 'suffixes',
		помещаются в конец списка.

			     *c_CTRL-I* *c_wildchar* *c_<Tab>* *c_подстановка*
значение опции 'wildchar'

		Выполняется поиск соответствий шаблону перед курсором.
		Первое найденной соответствие вставляется на место шаблона.
		(Замечание: это не работает внутри макросов, поскольку в
		качестве значения 'wildchar' как правило используется <Tab>
		или <Esc>, которые имеют специальное значение в некоторых
		макросах). При повторном вводе вставляется следующее
		соответствие, если такое имеется. После вставки последнего
		найденного соответствия круг замыкается и снова будет
		вставлено первое обнаруженное соответствие.
		Такое поведение может быть изменено при помощи опции
		'wildmode'.

							            *c_CTRL-N*
CTRL-N		Переход к следующему соответствию после использования
		'wildchar', если имеется несколько соответствий. В противном
		случае извлекается следующая командная строка из истории.

<S-Tab>							*c_CTRL-P* *c_<S-Tab>*
CTRL-P		После использования команды 'wildchar', которая привела к
		получению нескольких соответствий, перейти к предыдущему
		соответствию. В противном случае восстанавливается предыдущая
		командная строка из истории команд. <S-Tab> работает только в
		графическом интерфейсе, на Amiga и в MS-DOS.

								    *c_CTRL-A*
CTRL-A		Вставляются все имена, которые соответствуют шаблону перед
		курсором.

								    *c_CTRL-L*
CTRL-L		Выполняется поиск соответствий шаблону перед курсором. Если
		имеется одно соответствие, то оно вставляется вместо шаблона.
		Если имеется несколько соответствий, то на место шаблона
		вставляется наиболее длинная общая часть всех соответствий.
		Если результат короче, чем шаблон, то дополнения не
		происходит.

По умолчанию значением опции 'wildchar' является <Tab> (CTRL-E в режиме
совместимости с Vi; в предыдущих версиях использовался символ <Esc>). В
шаблоне принимаются стандартные символы подстановки '*' и '?'. '*'
соответствует любой строке, '?' соответствует ровно одному символу.

Если вам нравится автоматическая демонстрация списка дополнений в стиле tcsh,
то вы можете воспользоваться такой привязкой: >

	:cnoremap X <C-L><C-D>

(где X это командная кнопка, которую вы будете использовать, <C-L> это CTRL-L,
а <C-D> это <CTRL-D>). Это позволяет найти самое длинные соответствие, после
чего будет показан список соответствий.

Если вам нравится автоматическая демонстрация списка дополнений в стиле tcsh,
то для её эмуляции можно воспользоваться параметрами опции 'wildmode'.
Например, параметр autolist=ambiguous эмулируется так: >

	:set wildmode=longest,list

Это позволяет найти самое длинное соответствие после выполнения первой команды
'wildchar', а последующая команда приведёт к демонстрации списка всех
доступных файлов.

						       *suffixes* *расширения*
При дополнении имён файлов может быть использована опция 'suffixes', которая
задаёт приоритет для выбора между файлами, имеющими почти одинаковые имена.
При наличии нескольких соответствий файлы, расширения которых перечислены в
значении опции 'suffixes', игнорируются. Значением по умолчанию является
список ".bak,~,.o,.h,.info,.swp,.obj", что заставляет редактор в некоторых
случаях игнорировать файлы, которые заканчиваются на ".bak", "~", ".o", ".h",
".info", ".swp" и ".obj". Расширение с двумя точками проигнорировать
невозможно. Примеры:

   шаблон:      файлы:				соответствие:	~
   test*	test.c test.h test.o		test.c
   test*	test.h test.o			test.h and test.o
   test*	test.i test.h test.c		test.i and test.c

Если после того, как были проигнорированы файлы с расширениями, указанными в
значении опции 'suffixes', было обнаружено несколько соответствий, то при
дополнении вставляется первое найденной имя файла. Проверить количество
найденных соответствий можно при помощи повторного ввода команды 'wildchar':
если дополнение не изменяется, то это указывает, что обнаружено только одно
соответствие. Остальные соответствия могут быть вставлены при помощи команды
'wildchar' или команд CTRL-N и CTRL-P. При этом включаются все файлы, в том
числе и те, расширения которых соответствуют значению опции 'suffixes'.

Чтобы полностью игнорировать файлы с определёнными расширениями, используйте
опцию 'wildignore'.

Текущее значение опции можно получить при помощи ввода команды 'wildchar'
сразу после ввода '='. Например, при вводе команды 'wildchar' сразу после
ввода ":set dir=", будет вставлено текущее значение опции 'dir'. Это правило
имеет более высокий приоритет, чем правила дополнения имён файлов, при работе
с опциями, принимающими в качестве значения имена файлов.

Если вы желаете использовать в xterm <S-Tab> вместо CTRL-P, то вам следует
поместить в файле .cshrc следующую команду: >

	xmodmap -e "keysym Tab = Tab Find"

А в файле .vimrc написать >

	:cmap <Esc>[1~ <C-P>

==============================================================================
3. Командные строки Ex 		     *cmdline-lines* *командная_строка-строки*

Команды Ex имеют ряд особенностей:

						           *:quote* *:кавычка*
'"' в начале строки заставляет Vim игнорировать всю строку. '"' после команды
заставляет редактор игнорировать оставшуюся часть строки. Этим можно
пользоваться для вставки комментариев. Например: >

	:set ai		"установить опцию 'autoindent'
	
Добавление комментария невозможно при выполнении команды оболочки с помощью
":!cmd" или при использовании команд семейства ":map", поскольку они
воспринимают символ '"' как часть своего аргумента.

						    *:bar* *:\bar*
'|' может использоваться для разделения команд, что позволяет указывать в
одной строке сразу несколько команд. Если вам необходимо использовать символ
'|' в качестве аргумента команды, то его необходимо предварять при помощи
косой черты '\'.

Указанные ниже команды воспринимают '|' в качестве аргумента, поэтому вслед за
ними не может быть использована другая команда:

    :argdo
    :autocmd
    :bufdo
    :command
    :cscope
    :debug
    :folddoopen
    :folddoclosed
    :function
    :global
    :help
    :helpfind
    :make
    :normal
    :perl
    :perldo
    :promptfind
    :promptrepl
    :pyfile
    :python
    :registers
    :read !
    :scscope
    :tcl
    :tcldo
    :tclfile
    :vglobal
    :windo
    :write !
    :[диапазон]!
    определённые пользователем команды без аргумента "-bar", см. |:command|.

Обратите внимание, что имеется некоторая непоследовательность, наследованная
из Vi: в команде ":g" символ '|' включается в команду, а в команде ":s" --
нет.

Чтобы использовать другую команду в таких случаях, необходимо воспользоваться
командой ":execute". В качестве примера приведём команду, которая добавляет
вывод команды оболочки "ls" и затем перемещает курсор в первую строку: >

	:execute 'r !ls' | '[

Имеется одно исключение: когда в опции 'cpoptions' указан флаг 'b', то при
использовании команд ":map" и ":abbr", а также их вариантов, вместо '\'
следует использовать CTRL-V. Кроме того, можно также использовать "<Bar>". 
См. также |map-вертикальная_черта|.

Примеры: >

	:!ls | wc		просмотр вывода двух команд
	:r !ls | wc		вставка результата выполнения двух команд в
					файл
	:%g/foo/p|>		смещение всех строк с соответствием на
					величину одного отступа
	:%s/foo/bar/|>		перемещение одной строки на один отступ
	:map q 10^V|		привязка "q" к "10|"
	:map q 10\| map \ l	привязка "q" к "10\" и "\" к "l"
					(если в 'cpoptions' указан флаг 'b')

Чтобы разделить несколько команд можно также использовать символ <NL>. Для
вставки этого символа используется последовательность CTRL-V CTRL-J. На экране
при этом отображается "^@". Хотя применение '|' является более
предпочтительным методом, при выполнении внешних команд использование <NL> 
является единственным способом, поскольку '|' включается во внешнюю команду.
Чтобы избежать специального применения символа <NL>, его следует предварять
обратной косой чертой. Пример: >

	:r !date<NL>-join

Эта команда позволяет вставлять текущую дату в файл, склеивая её с предыдущей
строкой.

Обратите внимание, что если выполнение команды перед символом '|' приводит к
возникновению ошибки, то последующие команды выполняться не будут.


Для совместимости с Vi поддерживаются следующие странные команды: >

	:|			печать текущей строки (как ":p")
	:3|			печать строки 3 (как ":3p")
	:3			переход к строке 3

Между диапазоном и именем команды допустимо двоеточие, которое игнорируется
(это также диктуется требованиями совместимости с Vi). Например: >

	:1,$:s/pat/string

При использовании символа '%' или '#' в том месте, где ожидается ввод имени
файла, они заменяются на имя текущего и соседнего файла (см. главу о
редактировании файлов, |:_%| |:_#|).

На Amiga допускается использование пробелов в именах фалов, в том случае, если
в качестве аргумента ожидается ввод одного имени файла. Пробелы на конце имени
игнорируются, если они не экранируются при помощи символа обратной косой черты
или CTRL-V. Обратите внимание, что команда ":next" использует пробелы для
разделения имён файлов. Чтобы пробелы могли быть включены в состав имени,
их требуется также экранировать. Пример: >

	:next foo\ bar goes\ to school\
	
Эта команда позволяет начать редактирование трёх файлов: "foo bar", "goes to"
и "school ".

Если вы желаете использовать в команде специальный символ '"' или '|', либо
хотите использовать '%' или '#' в имени файла, то их также следует
экранировать символом обратной косой черты. Использование символа обратной
косой черты не требуется в диапазоне и в команде ":substitute".

									 *:_!*
Символ восклицательного знака '!' после команды Ex изменяет поведение команды.
Символ '!' должен быть помещён немедленно после команды, без пробелов между
'!' и командой. Если перед '!' будут вставлены пробелы, то '!' будет
восприниматься в качестве аргумента команды, что приводит к иным результатам.
Например: 

	:w! name	запись текущего буфера в файл "name", с перезаписью
			прежнего содержимого файла, если он существует
	:w !name	отправка содержимого текущего буфера на стандартный
			ввод команды "name"

==============================================================================
                                                    *cmdline-ranges* *[range]* 
					             *E16* *E493* *[диапазон]*
4. Диапазоны в командной строке Ex                *командная_строка-диапазоны*

Некоторые команды Ex допускают указание перед командой диапазона строк. В
описании команд это отмечается как [диапазон]. Диапазон состоит из одного и
более указателей на строки, разделённых ',' или ';'.

Основные сведения о диапазонах приводятся в разделе |10.3| руководства
пользователя.

						                     *:,* *:;*
Если указатели строк в диапазоне разделены символом ';', то курсор
устанавливается в соответствующую строку перед тем, как происходит поиск
следующей строки диапазона. Этого не происходит, если указатели разделены при
помощи символа ','. Примеры: >

   4,/эта строка/
<	от строки 4 до соответствия выражению "эта строка" после строки, в
	которой находится курсор. >
   5;/та строка/
<	от строки 5 до соответствия выражению "та строка" после строки 5.	    

Указателем строки по умолчанию в большинстве команд является строка, в которой
находится курсор, однако для команд ":write" и ":global" по умолчанию
используется весь файл целиком (1,$).

Если указано больше указателей строки, чем это требуется данной командой, то
будут игнорироваться лишние указатели в начале выражения диапазона.

                                                    *:range* *E14* *{address}*
Строки могут быть заданы следующим образом:	         *:диапазон* *{адрес}*

	{число}		абсолютный номер строки
	.		текущая строка			                  *:.*
	$		последняя строка в файле		          *:$*
	%		равноценно 1,$ (весь файл)		          *:%*
	't		позиция отметки t (в нижнем регистре)		  *:'*
	'T		позиция отметки T (в верхнем регистре); если отметка
			находится в другом файле, то она не может быть
			использована в диапазоне
	/{шаблон}[/]	следующая строка с соответствием {шаблону} 	  *:/*
	?{шаблон}[?]	предыдущая строка с соответствием {шаблону}	  *:?*
	\/		следующая строка с соответствием раннее
			использованному шаблону поиска
	\?		предыдущая строка с соответствием раннее
			использованному шаблону поиска
	\&		следующая строка с раннее использованным шаблоном
			замены

За каждым таким указателем строки может следовать знак '+' или '-' и число,
которое добавляется или вычитается из номера указанной строки. Если число не
указано, то по умолчанию принимается значение 1.

Символы "/" и "?" после {шаблона} требуются для отделения шаблона от следующих
за ним символов.

Перед символами "/" и "?" может быть указан другой адрес, в этом случае поиск
начинается с указанного адреса. Отличие такой формы записи от использования
";" состоит в том, что в этом случае курсор не перемещается. Примеры: >

	/шаблон1//шаблон2/  Указывает на строку, содержащую "шаблон2" после
			    строки "шаблон1" без перемещения курсора
	7;/шаблон2/	    Найти строку, содержащую "шаблон2" после строки 7,
			    помещая курсор в строке 7.

Заданное {число} должно лежать в пределах между 0 и числом строк в файле. Если
число равно 0, то большинство команд интерпретирует это значение как 1.
Команды, которые используют число в качестве счётчика, интерпретируют это
значение как 0 (|:tag|, |:pop|, и т.д.). Некоторые команды рассматривают
значение 0 как "строка перед первой строкой" (|:read|, шаблоны поиска и т.д.).

Примеры: >

	.+3		три строки ниже позиции курсора
	/это/+1		строка, которая находится под строкой, следующей после
			строки, в которой содержится слово "это"
	.,$		от текущей строки до конца файла
	0;/это		первая строка, в которой содержится слово "это", а
			также первая строка файла
	1;/это		первая строка после строки 1, в которой содержится
			слово "это"

Некоторые команды позволяют указывать после команды число-счётчик. Такой
счётчик указывает на количество строк, которые будут затронуты командой,
начиная со строки, определённой последним указателем (по умолчанию -- текущая
строка). Команды, которые позволяют задавать счётчик это те команды, которые
используют диапазон, но не используют в качестве аргумента имя файла
(поскольку имя файла может быть числом).

Примеры: >
	:s/x/X/g 5	заменить 'x' на 'X' в текущей и четырёх последующих
			строках
	:23d 4		удалить строки 23, 24, 25 и 26


Складки и диапазоны

При включённых складках номера строк округляются до значений, позволяющих
включать закрытые складки целиком. См. |складки-поведение|.


Обратные диапазоны

Строка с меньшим номером должна быть указана в диапазоне перед строкой с
большим номером. Если это не так, то Vim предложит поменять указатели строк
местами, однако этого не произойдёт, если диапазон используется внутри
глобальной команды ":g".


Счётчики и диапазоны						          *N:*

При указании числа перед вводом ":", оно интерпретируется как

		:.,.+(число - 1)
		
Другими словами, заданное "число" строк, начиная с позиции курсора. Например,
для удаления трёх строк можно использовать команду >

		3:d<CR>		то же, что и .,.+2d<CR>
<

Визуальный режим и диапазоны 					         *v_:*

{Визуально}:	Командная строка применяется к диапазону выделенных в
		Визуальном режиме строк. Для такого диапазона используется
		специальный код ":'<,'>", что позволяет повторять команды из
		истории команд для различных визуальных выделений.

==============================================================================
5. Специальные символы Ex     *cmdline-special* *командная_строка-спецсимволы*

В командах Ex ряд символов может иметь специальное значение в тех местах, где
используется имя файла. Эти символы также могут быть использованы в функции
expand(), см. |expand()|.

	%	заменяется именем текущего файла			 *:_%*
	#	заменяется именем соседнего файла		         *:_#*
	#n	(где n является числом) заменяется именем файла в буфере с
		заданным номером. При этом "#0" это то же, что и "#".
	##	заменяется полным набором файлов в списке аргументов, 	*:_##*
		разделённых пробелами. Каждый пробел в имени файла
		предваряется символом обратной косой черты.

Обратите внимание, что имя файла подставляется в том виде, как оно было
набрано. Если требуется абсолютный путь к файлу (при использовании файла из
другого каталога), то вам потребуется добавить ":p".
См. |имя_файла-модификаторы|.
Также обратите внимание, что в имени файла перед пробелами вставляется символ
обратной косой черты, чтобы команда могла правильно обработать имя файла.
Однако, этого не происходит при работе с командами оболочки. При использовании
команд оболочки вам возможно понадобится заключать символ в кавычки: >

	:!ls "%"
	:r !spell "%"

Чтобы отказаться от использования специального значения символов '%' и '#', их
следует предварять символом обратной косой черты. Заметим, что специальное
значение этих символов всегда экранируется при использовании обратной косой
черты перед символом, вне зависимости от числа символов обратной косой.

	   набор символов	результат ~
	   #			соседний.файл
	   \#			#
	   \\#			\#

			            *:<cword>* *:<cWORD>* *:<cfile>* *<cfile>*
			             *:<sfile>* *<sfile>* *:<afile>* *<afile>*
			             *:<abuf>* *<abuf>* *:<amatch>* *<amatch>*
			             *E495* *E496* *E497* *E498* *E499* *E500*
				     
Замечание: эти последовательности вводятся буквально; они не являются
специальными символами!

	<cword>    заменяется на слово в позиции курсора (как |звёздочка|)
	<cWORD>    заменяется СЛОВОМ в позиции курсора (см. |СЛОВО|)
	<cfile>    заменяется путём к файлу в позиции курсора (используются
		   правила, аналогичные команде |gf|)
	<afile>    при выполнении автокоманды заменяется именем файла для
		   чтения или записи
	<abuf>     при выполнении автокоманд заменяется текущим эффективным
		   номером буфера (для команды ":r файл" это текущий буфер,
		   читаемый файл не находится в буфере).
	<amatch>   при выполнении автокоманд заменяется соответствием, для
		   которого выполняется данная автокоманда. Это отличается от
		   <afile> только в том случае, если для соответствия не
		   используется имя файла (для событий FileType и Syntax).
	<sfile>    при выполнении команды ":source" заменяется на имя
		   считываемого файла; 
		   при выполнении функции заменяется на "function
		   {имя-функции}";
		   вложение вызовов функций указывается следующим образом:
		   "function {имя-функции-1}..{имя-функции-2}".
		   Обратите внимание, что модификаторы имени файла бесполезны
		   в том случае, когда <sfile> используется внутри функции.

			         *filename-modifiers* *имя_файла-модификаторы*
           *:_%:* *::8* *::p* *::.* *::~* *::h* *::t* *::r* *::e* *::s* *::gs*
Модификаторы имени файла могут использоваться после специальных символов "%",
"#", "#n", "<cfile>", "<sfile>", "<afile>" и "<abuf>". Кроме того, они также
используются в функции |fnamemodify()|. Эти модификаторы доступны только в том
случае, если Vim собран с особенностью |+modify_fname|.

Модификаторы могут указываться в следующем порядке:

	:p	Использовать полный путь к файлу. Это должен быть самый первый
		модификатор. Он также заменяет "~/" (и "~user/" в Unix и VMS)
		на путь к домашнему каталогу пользователя. Если имя является
		каталогом, то в конец пути добавляется разделитель компонентов
		пути. Если файл с таким именем не существует и не может иметь
		абсолютного пути, то результат непредсказуем.
	:8	Превращает путь в формат коротких имён 8.3 (в данный момент
		только на win32). Этот модификатор будет работать только с
		теми компонентами пути, которые существуют.
	:~	Преобразует путь к файлу в путь относительно домашнего
		каталога. Имя файла не изменяется, если он не находится по
		пути от домашнего каталога.
	:.	Преобразует путь к файлу в путь относительно текущего
		каталога, если это возможно. Имя файла остаётся без изменений,
		если он не находится по пути от текущего каталога.
		Для максимального сокращения пути используйте ":~:.".
	:h	Голова имени файла (последний компонент пути без
		разделителей). Этот модификатор не может быть использован
		совместно с :e, :r или :t. Модификатор может повторяться для
		удаления нескольких компонентов в конце имени файла. Если имя
		файла заканчивается разделителем компонентов пути, то
		удаляется только разделитель компонента пути. Таким образом,
		":p:h" для пути к каталогу приводит к выделению самого имени
		каталога (без завершающей косой черты).
		Если имя файла является абсолютным путевым именем (т.е.
		начинается с "/" в Unix, "x:\" в MS-DOS, WIN32, OS/2 или
		"drive:" на Amiga), то эта часть не будет удаляться. Если
		голова файла отсутствует (например, путь задан относительно
		текущего каталога), то результатом будет пустая строка.
	:t	Хвост имени файла (последний компонент имени файла). Должен
		быть указан перед модификаторами ":r" или ":e".
	:r	Корень имени файла (без последнего расширения). Если в имени
		файла присутствует только расширение (имя файла начинается с
		символа '.', например ".vimrc"), то оно не будет удаляться.
		Модификатор может быть повторён для удаления нескольких
		расширений, при этом в первую очередь удаляется последнее
		расширение.
	:e	Расширение имени файла. Использование модификатора имеет смысл
		только в том случае, когда не используются другие
		модификаторы. Если расширение файла отсутствует, то
		результатом будет пустая строка. Модификатор может повторяться
		для включения в результат дополнительных расширений. Если
		расширений недостаточно (но имеется хотя бы одно), то будет
		включено максимально возможное количество расширений.
	:s?pat?sub?
		Подстановка строки "sub" на место первого соответствия шаблону
		"pat". Модификатор работает аналогично команде |:s|. Шаблон
		"pat" является регулярным выражением. Вместо '?' может быть
		использован любой символ, которые не встречается в "pat" и
		"sub".
		После осуществления замены могут быть вновь использованы
		раннее описанные модификаторы. Например, ":p" для расширения
		имени в полное путевое имя после выполнения подстановки.
	:gs?pat?sub?
		Замена всех соответствий шаблону "pat" на строку "sub". В
		остальном модификатор работает аналогично ":s".

В примерах ниже считается, что имя файла "src/version.c", а текущий каталог
"/home/mool/vim": >

  :p			/home/mool/vim/src/version.c
  :p:.				       src/version.c
  :p:~				 ~/vim/src/version.c
  :h				       src
  :p:h			/home/mool/vim/src
  :p:h:h		/home/mool/vim
  :t					   version.c
  :p:t					   version.c
  :r				       src/version
  :p:r			/home/mool/vim/src/version
  :t:r					   version
  :e						   c
  :s?version?main?		       src/main.c
  :s?version?main?:p	/home/mool/vim/src/main.c
  :p:gs?/?\\?		\home\mool\vim\src\version.c

Примеры для имени файла "src/version.c.gz": >

  :p			/home/mool/vim/src/version.c.gz
  :e						     gz
  :e:e						   c.gz
  :e:e:e					   c.gz
  :e:e:r					   c
  :r				       src/version.c
  :r:e						   c
  :r:r				       src/version
  :r:r:r			       src/version
<
		         *extension-removal* *избавление_от_расширений* *:_%<*
Расширение файла (т.е. символы, входящие в имя файла после последнего символа
'.', включая саму точку) может быть удалено при помощи добавления символа "<"
к специальным символам "%", "#", "#n" или "CTRL-V p". Эта возможность
сохраняется для обратной совместимости с версией 3.0, более предпочтительно
использовать модификатор ":r". Примеры: >

	%		имя текущего файла
	%<		имя текущего файла без расширения
	#		имя соседнего файла для данного окна
	#<		то же, но без расширения
	#31		соседний файл номер 31
	#31<		то же, но без расширения
	<cword>		слово в позиции курсора
	<cWORD>		СЛОВО в позиции курсора (см. |СЛОВО|)
	<cfile>		путевое имя в позиции курсора
	<cfile><	то же, но без расширения

Замечание: символы подстановки будут расширяться, если они указаны там, где
ожидается ввод имени файла. В Unix это выполняется средствами оболочки, если
такое расширение не может быть произведено встроенными механизмами (для
увеличения быстродействия). Обратные кавычки также работают, как например в
команде >

	:n `echo *.c`

(обработка выражений в обратных кавычках невозможна в |ограниченном_режиме|).

Расширение символов подстановки происходит только в том случае, если символы
подстановки встречаются перед символами '%', '#' и т.д. Это позволяет избежать
расширения символов подстановки внутри имени файла. Если вы желаете расширить
результат обработки <cfile>, то добавьте к нему символ подстановки. Примеры,
для случая, когда имя соседнего файла "?readme?": 

	команда		расширяется до команды  ~
	:e #		:e ?readme?
	:e `ls #`	:e {файлы, соответствующие "?readme?"}
	:e #.*		:e {файлы, соответствующие "?readme?.*"}
	:cd <cfile>	:cd {имя файла в позиции курсора}
	:cd <cfile>*	:cd {имя файла в позиции курсора с добавлением символа
			    "*", которое затем расширяется}

Если расширяемый аргумент содержит "!" и используется в команде оболочки
(":!cmd", ":r !cmd" или ":w !cmd"), то он экранируется символом обратной косой
черты, чтобы он не был расширен в раннее использованной команде. Если
значение опции 'shell' содержит "sh", то этот процесс происходит дважды, чтобы
предотвратить расширение "!" оболочкой.

			       *filename-backslash* *имя_файла-обратная_косая*
В файловых системах, которые используют символ обратной косой черты в качестве
разделителя каталогов (MS-DOS, Windows, OS/2) иногда бывает затруднительно
отличить символ обратной косой, который используется для экранирования
специального значения следующего за ним символа. Основное правило, которое
используется в таких случаях, следующее: если обратная косая черта предваряет
обычный символ имени файла, то этот символ не имеет специального значения.
Поэтому, "\file\foo" является обычным именем файла, при записи которого нет
необходимости вводить двойной символ обратной косой.

Исключением из этого правила является использование символа '$'. Такой символ
является допустимым для использования в имени файла. Однако, при его
использовании необходимо вводить экранирующий символ  обратной косой черты.
Так, для ввода файла "$home" в корневом каталоге, следует писать "/\$home".
Несколько примеров:

	ИМЯ ФАЙЛА	ИНТЕРПРЕТАЦИЯ	~
	$home		соответствует значению переменной окружения $home
	\$home		файл "$home" в текущем каталоге
	/\$home		файл "$home" в корневом каталоге
	\\$home		файл, начинающийся с символов "\\", за которыми
			следует значение переменной окружения $home

==============================================================================
6. Окно командной строки     *cmdline-window* *cmdwin* *командная_строка-окно*

В окне командной строки можно редактировать командную строку как обычный текст
в любом окне. Это окно является особенным в том смысле, что его нельзя
покинуть обычным способом.
{доступно только в том случае, если Vim скомпилирован с особенностями
|+cmdline_hist| и |+vertsplit|}


ОТКРЫТИЕ ОКНА

Имеется два способа открыть окно командной строки:

1. Из режима Командной строки при помощи кнопки, указанной в значении опции
   'cedit'. По умолчанию используется кнопка CTRL-F, если опция 'compatible'
   выключена.
2. Из Обычного режима при помощи команд "q:", "q/" или "q?". *q:* *q/* *q?*
   Эти команды используются для редактирования командной строки Ex ("q:") или
   строки поиска ("q/" или "q?"). Обратите внимание, что выполнение этой
   команды при включённой записи невозможно (поскольку "q" прекращает запись).

При открытии окна оно заполняется историей командной строки. Последняя строка
в окне содержит введённый к этому моменту фрагмент команды. В левой колонке
отображается символ, соответствующий типу командной строки, см.
|окно_команд-символы|.

При открытии окна Vim переходит в Обычный режим, кроме случая, когда включена
опция 'insertmode'.

Высота окна задаётся при помощи опции 'cmdwinheight' (но может быть меньше
заданного значения, если на экране не хватает места). Окно командной строки
всегда занимает полную ширину экрана и располагается непосредственно над
командной строкой.


РЕДАКТИРОВАНИЕ

После открытия окна командной строки в нём можно перемещаться и редактировать
текст при помощи обычных средств, как в Обычном режиме, так и в режиме
Вставки.

При работе в окне командной строки возможно использование команд, использующих
командную строку, таких как ":", "/" и других, но открытие другого окна
командной строки невозможно. Вложения одного окна командной строки в другое не
происходит.
							                 *E11*
Окно командной строки отличается от обычных окон. При редактировании
содержимого окна командной строки нельзя перемещаться в другое окно или
редактировать другой буфер. В окне командной строки не работают команды,
вызывающие подобные переходы к редактированию других файлов. Само собой,
выполнение любой команды, введённой в окне командной строки  _возможно_.


ЗАКРЫТИЕ ОКНА							        *E199*

Существует несколько способов закрыть окно командной строки:

<CR>		Выполнить командную строку в позиции курсора. Это работает как
		в Обычном режиме, так и в режиме Вставки.
CTRL-C		Продолжить работу в режиме командной строки. При этом
		командная строка в позиции курсора переносится из окна в
		командную строку. Это работает как в Обычном режиме, так и в
		режиме Вставки. Кроме того, возможно использование команды
		":close". При этом обновление экрана не происходит, так что
		окно командной строки остаётся перед глазами.
:quit		Отмена ввода командной строки и возвращение в Обычный режим.
		Для этого также можно использовать команды ":exit", ":xit" и
		CTRL-\ CTRL-N.
:qall		Выход из редактора Vim, кроме случаев, когда в одном или
		нескольких буферах имеются несохранённые изменения.
:qall!		Выход из редактора Vim с отменой несохранённых изменений в
		любом буфере.

После того как окно командной строки будет закрыто размеры открытых окон
восстанавливаются.  Выполняемая команда применяется к окну и буферу, из
которых был выполнен переход в режим командной строки. Иными словами, всё
работает так, будто окна командной строки не было вовсе, но с дополнительным
обновлением экрана. 
Буфер, который использовался для окна командной строки, удаляется. Все
изменения, выполненные в командных строках утрачиваются, кроме строки, которая
выполняется при нажатии <CR>.


РАЗЛИЧНЫЕ КОММЕНТАРИИ

Окно командной строки не может быть использовано:

- в том случае, если уже открыто другое окно командной строки (вложенность не
  допускается);
- для ввода пароля шифрования или при использовании функции inputsecret();
- если Vim не был собран со включённой особенностью +vertsplit.

При открытии окна командной строки дополнительно устанавливается значение
некоторых опции:

'filetype'	"vim" при редактировании командной строки Ex; эта опция
		позволяет включать подсветку синтаксиса, если она
		необходима
'rightleft'	выключается
'modifiable'	включается
'buftype'	"nofile"
'swapfile'	выключается

Содержимое буфера позволяется сохранять в отдельный файл. Таким образом,
имеется простое средство сохранения истории командной строки в файл для
последующего прочтения.

Если значение опции 'wildchar' установлено равным <Tab> и используется окно
командной строки для редактирования команды Ex, то для дополнения в окне
командной строки будут добавлены следующие привязки для кнопки <Tab>: >

	:imap <buffer> <Tab> <C-X><C-V>
	:nmap <buffer> <Tab> a<C-X><C-V>

Обратите внимание, что нажатие <Tab> в Обычном режиме приводит к выполнению
дополнения на следующем символе. Именно так дополнение работает в конце
строки. Если вам не нравятся эти привязки, то их можно отменить следующими
командами: >

	au CmdwinEnter [:>] iunmap <Tab>
	au CmdwinEnter [:>] nunmap <Tab>

Эти команды можно поместить в файл настроек vimrc.

При нахождении в окне командной строки вы не можете пользоваться мышью для
помещения курсора в другое окно или перемещения строки состояния других окон.
В то же время вы можете перемещать строку состояния самого окна командной
строки и окна, которое находится над ним. Таким образом, у вас есть
возможность изменять размер окна командной строки, но не других окон.


АВТОКОМАНДЫ

Применяется два события автокоманд: |CmdwinEnter| и |CmdwinLeave|. Поскольку
окно командной строки это не совсем обычное окно, то события WinEnter,
WinLeave, BufEnter и BufLeave не используются. Для настройки автокоманд
специально для окна командной строки можно использовать события Cmdwin. При
этом следует остерегаться побочных эффектов.
Пример: >

	:au CmdwinEnter :  let b:cpt_save = &cpt | set cpt=v
	:au CmdwinLeave :  let &cpt = b:cpt_save

Этот набор команд включает опцию 'complete' для выполнения дополнения
командной строки в режиме Вставки для CTRL-N.

Другой пример: >

	:au CmdwinEnter [/?]  startinsert

Эта команда переводит Vim в режим Вставки сразу после перехода в окно
командной строки.

			                   *cmdwin-char* *окно_команд-символы*
Символ, который используется для шаблона, указывает на тип командной строки:

	:	обычная команда Ex
	>	команда режима отладки |режим_отладки|
	/	строка поиска в прямом направлении
	?	строка поиска в обратном направлении
	=	выражение для "= |выражение-регистр|
	@	строка для |input()|
	-	текст для |:insert| или |:append|

==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
