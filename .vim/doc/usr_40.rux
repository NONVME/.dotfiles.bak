*usr_40.txt*	Для Vim version 6.3.  Последнее изменение: 2004 Feb 13

		РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ VIM - Брам Мооленаар

			    Создание новых команд


Vim это редактор с расширяемой функциональностью. Вы можете превратить
последовательность часто используемых команд в новую команду, переопределить
существующую команду или использовать автокоманды для автоматического
выполнения команд.

|40.1|	Привязки клавиш
|40.2|	Определение новых команд для режима командной строки
|40.3|	Автокоманды

 Следующая глава: |usr_41.txt|  Написание сценариев Vim
Предыдущая глава: |usr_31.txt|	Работа с графическим интерфейсом
      Содержание: |usr_toc.txt|

==============================================================================
*40.1*	Привязки клавиш

Простые примеры использования привязок клавиш приводились в |05.3|. Смысл
привязок заключается в том, что одна последовательность нажатий на кнопки
преобразуется в другую последовательность нажатий. Несмотря на такую простоту,
это, между тем, довольно мощный механизм. 
   Простейшая форма привязки заключается в установке соответствия между
нажатием на какую-либо кнопку и последовательностью других нажатий на кнопки.
Поскольку функциональные клавиши, за исключением <F1> не имеют каких-либо
предустановленных значений в Vim, то их вполне можно использовать для
привязок. Простой пример: >

	:map <F2> GoДата: <Esc>:read !date<CR>kJ

эта команда позволяет использовать три режима. После перехода к последней
строке в файле по команде "G", открывается новая строка при помощи команды
"o", и редактор переходит в режим Вставки. Далее, вставляется текст "Дата: " и
используется кнопка <Esc> для возврата в Обычный режим.
   Обратите внимание на использование <> для специальных кнопок. Мы называем
это соглашением об угловых скобках. Все символы набираются буквально, без
нажатия на специальную кнопку. Это позволяет сделать привязки более читаемыми
и вы можете без проблем копировать и вклеивать требуемые команды. 
   Символ ":" переводит редактор в режим Командной строки. Команда ":read
!date" считывает вывод системной команды "date" и добавляет его под текущей
строкой. Для выполнения команды ":read" требуется ввод <CR>.
   Во время выполнения текст выглядит так:

	Дата:  ~
	пятница, 15 июня 2001 г. 12:54:34 (MSK) ~

Затем команда "kJ" перемещает курсор на строку вверх и объединяет обе строки
в одну.
   О том, как выбирать кнопки для привязок, читайте в |привязки-выбор_кнопок|.


ПРИВЯЗКИ И РЕЖИМЫ РЕДАКТОРА

Команда ":map" определяет привязки для клавиш в Обычном режиме. Вы также
можете использовать привязки для других режимов. Команда ":imap" определяет
привязки для режима Вставки. Этой командой можно пользоваться, например, для
вставки даты в текущей позиции текста: >

	:imap <F2> <CR>Дата: <Esc>:read !date<CR>kJ

Как видите, команда очень похожа на приведённую раннее привязку для <F2> в
Обычном режиме, всё различие только в начале команды. При этом привязка для
<F2> в Обычном режиме никуда не девается, поэтому можно пользоваться одной и
той же кнопкой для выполнения различных команд в зависимости от режима.
   Обратите внимание, что хотя эта привязка начинает выполнение команд в
режиме Вставки, заканчивается оно уже в Обычном режиме. Если вы хотите
продолжать режим Вставки, то добавьте к определению привязки "a".

Вот список команд для определения привязок с указанием режимов, в которых
определённые с их помощью привязки будут работать:

	:map		Обычный, Визуальный и режим ожидания оператора
	:vmap		Визуальный
	:nmap		Обычный
	:omap		Ожидание оператора
	:map!		Вставка и Командная строка
	:imap		Вставка
	:cmap		Командная строка

Режим ожидания оператора это режим, в который переходит редактор после ввода
команды-оператора, например "d" или "y". Называется он так потому, что
редактор ожидает ввода текстового объекта или команды перемещения для указания
области применения оператора. Иными словами, при вводе команды "dw", кнопка
"w" нажимается в режиме ожидания оператора.

Предположим, что вы хотите использовать кнопку <F7> так, чтобы команда d<F7>
удаляла программный блок на языке C (т.е. текст внутри фигурных скобок {}).
Аналогичным образом, команда y<F7> будет копировать программный блок в
безымянный регистр. Для этого вам потребуется привязать выделение текущего
программного блока к кнопке <F7>. Это можно сделать при помощи следующей
команды: >

	:omap <F7> a{

Эта команда привязывает текстовый объект "a{" к кнопке <F7> в режиме ожидания
оператора. Такая привязка окажется полезной в том случае, если набор { на
клавиатуре вызывает затруднения.


СПИСОК ПРИВЯЗОК

Чтобы посмотреть список текущих привязок, используйте команду ":map" без
аргументов. Также можно использовать соответствующую команду для определённых
режимов, в которых работает привязка. Вывод выглядит примерно так:

	   _g		 :call MyGrep(1)<CR> ~
	v  <F2>		 :s/^/> /<CR>:noh<CR>`` ~
	n  <F2>		 :.,$s/^/> /<CR>:noh<CR>`` ~
	   <xHome>	 <Home>
	   <xEnd>	 <End>


Первая колонка в списке показывает режим, в котором действует та или иная
привязка. Обычный режим обозначается "n", режим Вставки -- "i", и т.д.
Привязки определённые с помощью команды ":map", которые работают как в
Обычном режиме, так и в режиме Вставки, никак не отмечаются. 
   Одно из полезных применений списка привязок состоит в том, что с его
помощью легко проверить правильность распознавания специальных клавиш в
угловых скобках <> (при условии, что терминал поддерживает цвета). Если <Esc>
выделено в списке другим цветом, то это означает, что в привязке используется
специальная кнопка. Если же цветовое выделение отсутствует, то такая
последовательность будет распознаваться как пять отдельных символов. 


ПОДСТАНОВКА ПРИВЯЗОК В ПРИВЯЗКАХ

Значение привязки проверяется на предмет содержания других привязок. Например,
привязки для <F2> можно сократить следующим способом: >

	:map <F2> G<F3>
	:imap <F2> <Esc><F3>
	:map <F3>  oДата: <Esc>:read !date<CR>kJ

В Обычном режиме <F2> переходит к последней строке и затем редактор ведёт себя
так, как будто была бы нажата кнопка <F3>. В режиме Вставки <F2> прекращает
режим Вставки по нажатию <Esc> и затем также использует нажатие кнопки <F3>.
Для кнопки <F3> определена привязка, которая делает всю основную работу. 

Предположим, что вы никогда не пользуетесь режимом Ex и хотите использовать
команду "Q" для форматирования текста, как это было в прежних версиях Vim. Для
этого подойдёт такая привязка: >

	:map Q gq

Для тех редких случаев, когда вы всё таки хотите использовать режим Ex,
определим привязку "gQ" для Q: >

	:map gQ Q

Однако, здесь мы сталкиваемся с определённой проблемой! Когда мы вводим
команду "gQ", она оказывается привязана к команде "Q", но, поскольку "Q"
привязана к "gq", то ввод команды "gQ" фактически выполняет команду "gq", в
результате чего мы не сможем попасть в режим Ex.
   Чтобы избежать использования привязок внутри привязок, воспользуемся вместо
этого командой ":noremap": >

	:noremap gQ Q

Теперь Vim знает, что "Q" не будет проверяться на предмет существования других
привязок. Подобные команды существуют также для всех режимов:

	:noremap	Обычный, Визуальный и режим ожидания оператора
	:vnoremap	Визуальный
	:nnoremap	Обычный
	:onoremap	Ожидание оператора
	:noremap!	Вставка и Командная строка
	:inoremap	Вставка
	:cnoremap	Командная строка


РЕКУРСИВНЫЕ ПРИВЯЗКИ

Если привязка включает саму себя, то она будет выполняться постоянно. Это
свойство можно использовать для повторения какого-либо действия неограниченное
количество раз.
   Например, представьте что у вас есть список файлов, в первой строке которых
содержится указание на номер версии. Вы редактируете эти файлы одновременно,
запуская редактор по команде "vim *.txt". Итак, вы редактируете самый первый
файл. Определите следующую привязку: >

	:map ,, :s/5.1/5.2/<CR>:wnext<CR>,,

Теперь введите ",,". Как и следовало ожидать, начнёт отрабатываться привязка.
"5.1" в первой строке файла будет заменено на "5.2". Затем осуществляется
запись файла и переход к редактированию следующего файла. Привязка
оканчивается на ",,", поэтому в новом файле также будет выполнена эта
привязка, и т.д.
   Это будет продолжаться до тех пор, пока не появится сообщение об ошибке. В
данном случае это может быть файл, в котором команда замены не найдёт
соответствия шаблону "5.1". В это случае вы сможете вставить в текущий файл
строку "5.1" вручную и продолжить, снова вводя команду ",,". Выполнение также
будет приостановлено в том случае, когда будет невозможно выполнение команды
":wnext", что произойдёт после редактирования последнего файла в списке
аргументов. 
   Если выполнение привязки приводит к появлению ошибки на середине, то
оставшаяся часть привязки выполняться не будет. Выполнение привязки также
может быть прервано по команде CTRL-C (CTRL-Break на MS-Windows).


УДАЛЕНИЕ ПРИВЯЗКИ

Для удаления привязки используйте команду ":unmap" или аналогичную команду из
списка для соответствующего режима:

	:unmap		Обычный, Визуальный и режим ожидания оператора
	:vunmap		Визуальный
	:nunmap		Обычный
	:ounmap		Ожидание оператора
	:unmap!		Вставка и Командная строка
	:iunmap		Вставка
	:cunmap		Командная строка

Вы можете определить привязку, которая работает в Обычном режиме и в режиме
ожидания оператора, но не работает в Визуальном режиме. Для этого
воспользуемся специальным приёмом: сначала определим привязку для всех трёх
режимов сразу, а затем удалим её для Визуального режима:  >

	:map <C-A> /---><CR>
	:vunmap <C-A>

Обратите внимание, что символы "<C-A>" используются вместо нажатия на кнопку
CTRL-A.

Для удаления всех привязок одновременно вы можете использовать команду
|:mapclear|. Варианты этой команды для разных режимов вы наверняка сможете
угадать самостоятельно. Будьте осторожны с выполнением этой команды, т.к. её
нельзя отменить!


СПЕЦИАЛЬНЫЕ СИМВОЛЫ

Команда ":map" может использоваться совместно с другой командой. Для
разделения двух команд используется символ |. Это приводит к тому, что символ
| нельзя использовать в командах определения привязок. Вместо этого
используется пять символов <Bar>. Пример: >
>
	:map <F8> :write <Bar> !checkin %<CR>

То же самое относится и к команде ":unmap" с тем замечанием, что вам следует
быть внимательным к пробелам на конце команды. Это две разные команды: >
>
	:unmap a | unmap b
	:unmap a| unmap b

Первая из указанных команд будет пытаться удалить привязку для "a " с пробелом
на конце.

Для ввода пробела внутри привязки используйте семь символов <Space>: >

	:map <Space> W

Данная привязка позволяет использовать пробел для перемещения вперёд на одно
разделённое пробелом слово.

Сразу после привязки нельзя использовать комментарий, поскольку 
символ " воспринимается как часть привязки. Однако, вы можете использовать |",
что позволяет начать новую пустую команду с комментарием. Пример:
>
    :map <Space> W|     " Используйте пробел для перемещения на слово вперёд
<


ПРИВЯЗКИ И СОКРАЩЕНИЯ

Сокращения сильно напоминают привязки для режима Вставки. Аргументы
используются одинаково в обоих случаях. Основное отличие заключается в методах
их выполнения. Сокращение распознаётся после ввода несловарного символа после
набора слова, а привязка немедленно после набора последнего символа.
   Другое отличие состоит в том, что символы, используемые в сокращении,
вставляются в текст при наборе. После того как выполняется подстановка
сокращения, введённые символы удаляются и вместо них вставляется значение
сокращения. При вводе символов, используемых для привязки, в текст ничего не
вставляется до тех пор, пока не будет введён последний символ привязки. Если
включена опция 'showcmd', то введённые символы показываются в нижней строке
экрана Vim.
   Исключение составляют привязки, значение которых неясно до последнего
момента. Представьте, что вы определили такие привязки: >

	:imap aa foo
	:imap aaa bar

В этом случае, при вводе "aa" Vim еще не знает, какую из привязок следует
отработать, поэтому он будет ожидать ввода следующего символа. Если таким
символом будет "a", то в результате будет применяться вторая привязка (в текст
будет вставлено "bar"). Если этот символ будет, к примеру, пробелом, то тогда
будет отрабатываться первая привязка ("foo"), с последующей вставкой пробела.


И ЕЩЁ...

Слово <script> можно использовать для определения привязок, относящихся к
данному сценарию. См. |:map-<script>|.

Слово <buffer> можно использовать для определения привязок, относящихся к
определённому буферу. См. |:map-<buffer>|.

Слово <unique> можно использовать для того, чтобы команда определения
привязки выполнялась только в том случае, если данной привязки еще не
определено. В противном случае новое значение для привязки просто заменяет
собой определённое раннее. См. |:map-<unique>|.

Чтобы кнопка ничего не делала, привяжите её к <Nop> (пять символов). Следующая
команда приведёт к тому, что кнопка <F7> вообще ничего не будет делать: >

	:map <F7> <Nop>| map! <F7> <Nop>

После <Nop> не должно быть пробела.

==============================================================================
*40.2*	Определение новых команд для режима командной строки

Редактор Vim позволяет определять собственные команды. Такие команды
выполняются в точности так же, как и остальные команды режима Командной
строки. 
   Для определения команды используйте команду ":command". Например: >

	:command DeleteFirst 1delete

В данном случае при выполнении команды ":DeleteFirst" Vim будет выполнять
команду ":1delete", то есть удалит первую строку в файле.

	Замечание:
	Команды, определённые пользователем, должны начинаться с прописной
	буквы. Вы также не можете определить команды для ":X", ":Next" и
	":Print". Символ подчёркивания использовать нельзя! Цифры использовать
	можно, но не рекомендуется.

Чтобы посмотреть список пользовательских команд, выполните команду: >

	:command

Пользовательские команды могут сокращаться, в точности так же, как и
встроенные. Для выполнения пользовательской команды достаточно набрать ровно
столько символов, сколько необходимо для нахождения однозначного соответствия
определённой команде. Для подстановки полного имени команды можно использовать
автодополнение командной строки.


КОЛИЧЕСТВО АРГУМЕНТОВ

Команды, определённые пользователем, могут принимать аргументы. Количество
аргументов должно быть указано с помощью ключа -nargs. Поскольку команда
:DeleteFirst не использует аргументы, то её можно было бы определить и так: >

	:command -nargs=0 DeleteFirst 1delete

Однако, поскольку значение 0 принимается по умолчанию, то указывать "-nargs=0"
не является обязательным. Возможны следующие значения -nargs:

	-nargs=0	Аргументы не используются
	-nargs=1	Один аргумент
	-nargs=*	Любое количество аргументов
	-nargs=?	0 или 1 аргумент
	-nargs=+	1 или более аргументов


ИСПОЛЬЗОВАНИЕ АРГУМЕНТОВ

В определении команды аргументы представлены словом <args>. Например: >

	:command -nargs=+ Say :echo "<args>"

Теперь при наборе

	:Say Привет, мир

Vim будет выдавать сообщение "Привет, мир". Однако, если в тексте команды
встречается двойная кавычка, то команда работать не будет. Например: >

	:Say мы скажем "привет"

Чтобы спецсимволы могли быть использованы в строке аргументов с правильным
экранированием, используйте "<q-args>": >

	:command -nargs=+ Say :echo <q-args>

Теперь команда ":Say" будет выполняться как команда: >

	:echo "мы скажем \"привет\""

Слово <f-args> содержит ту же информацию, что и <args>, но в формате,
подходящем для использования в качестве аргументов функции. Например: 
>
	:command -nargs=* DoIt :call AFunction(<f-args>)
	:DoIt a b c

приводит к выполнению команды: >

	:call AFunction("a", "b", "c")


ДИАПАЗОН СТРОК

Некоторые команды принимают в качестве аргумента строковый диапазон. Чтобы
определить такую команду, необходимо использовать ключ -range. Возможны
следующие значения:

	-range		Возможно указание диапазона; по умолчанию -- текущая
			   строка
	-range=%	Возможно указание диапазона; по умолчанию -- весь файл
	-range={число}	Возможно указание в качестве диапазона числа строк, по
			   умолчанию принимается значение {число}

При указании диапазона, в команде используются слова <line1> и <line2> для
определения значений первой и последней строки в диапазоне. Например,
следующая команда определяет команду SaveIt, которая записывает указанный
диапазон строк в файл "save_file": >

	:command -range=% SaveIt :<line1>,<line2>write! save_file


ДРУГИЕ КЛЮЧИ

Некоторые ключи и соответствующие им слова для использования в командах:

	-count={число}		Команда может принимать числовую
				приставку-аргумент, её значение по умолчанию
				равняется {числу}. Значение приставки можно
				использовать в команде с помощью слова
				<count>.
	-bang			Команда может использовать !. Если есть !, то 
				<bang> будет работать как !.
	-register		При вызове команды можно указать регистр. (По
				умолчанию используется безымянный регистр.)
				Указанный регистр в команде подставляется
				вместо <reg> (или <register>).
	-complete={тип}		Тип используемого дополнения в командной
				строке. Список возможных значений см. в
				|:command-автодополнение|.
	-bar			За командой может следовать | и другая
				команда, либо " и комментарий.
	-buffer			Команда доступна только в текущем буфере.

Кроме того, используется также слово <lt> для подстановки вместо символа <.
Его необходимо применять для экранирования специального значения упомянутых
слов в <>.


ПЕРЕОПРЕДЕЛЕНИЕ И УДАЛЕНИЕ

Для переопределения существующей команды требуется добавление аргумента !: >

	:command -nargs=+ Say :echo "<args>"
	:command! -nargs=+ Say :echo <q-args>

Для удаления пользовательской команды используйте ":delcommand". Эта команда
принимает единственный аргумент, который указывает на имя команды. Пример: >

	:delcommand SaveIt

Для удаления всех определённых пользователем команд: >

	:comclear

Будьте внимательны, эта операция не может быть отменена!

Подробнее о командах, определяемых пользователем см. в справочнике:
|команды_пользователя|.

==============================================================================
*40.3*	Автокоманды

Автокоманда это такая команда, которая выполняется автоматически при
наступлении определённого события, например при записи или чтении файла, или
при изменении буфера. Благодаря автокомандам вы можете, например, научить Vim
понимать архивные файлы. Эта возможность используется в модуле |gzip|.
   Автокоманды -- чрезвычайно мощное средство. Пользуйтесь ими осторожно и они
станут вашими хорошими помощниками, позволяя избегать ввода многих команд
вручную. Однако, при неаккуратном обращении они могут доставить немало хлопот. 

Представьте, что вы изменяете отметку о времени редактирования файла, которая
размещена в конце файла, каждый раз когда файл сохраняется на диск. Прежде
всего следует определить функцию: >

	:function DateInsert()
	:  $delete
	:  read !date
	:endfunction

Эта функция должна вызываться всякий раз, когда сохраняются изменения в файле.
Чтобы это происходило, введите команду: >

	:autocmd FileWritePre *  call DateInsert()

"FileWritePre" это указание на событие, при наступлении которого выполняется
автокоманда: в данном случае непосредственно перед сохранением файла. "*" это
шаблон для имени файла, с которым применяется данная автокоманда, в данном
случае он соответствует любому имени файла.
   Если выполнить указанную команду, то Vim будет проверять любую из
существующих автокоманд для данного имени файла с соответствующим событием
FileWritePre перед тем, как приступить к записи файла по команде ":write".
   Синтаксис команды :autocmd следующий: >

	:autocmd [группа] {события} {шаблон_имени_файла} [nested] {команда}

Необязательный параметр [группа] используется для упрощения управлением
командами (подробнее об этом ниже). Параметр {события} перечисляет через
запятую события, наступление которых приводит к выполнению команды.
   {шаблон_имени_файла} это имя файла, обычно задаваемое с помощью масок.
Например, использование "*.txt" позволяет выполнять автокоманду для всех
файлов, которые заканчиваются на ".txt". Необязательный флаг [nested]
позволяет использовать вложенные автокоманды (см. ниже), и, наконец,
собственно {команда}, которую требуется выполнить.


СОБЫТИЯ

Одно из самых полезных событий называется BufReadPost. Оно наступает в момент
редактирования нового файла. Это событие часто используют для автоматической
установки необходимых опций. Например, вы знаете, что файлы "*.gsm" содержат
исходный код на языке ассемблера GNU. Чтобы использовать для этих файлов
корректные правила синтаксиса, определим следующую автокоманду: >

	:autocmd BufReadPost *.gsm  set filetype=asm

Если Vim в состоянии определить тип файла, то он установит правильное значение
опции 'filetype' автоматически. При этом наступает событие Filetype. Это
событие можно использовать для выполнения определённых действий при
редактировании определённого типа файла. Например, для загрузки списка
сокращений, используемых в текстовых файлах: >

	:autocmd Filetype text  source ~/.vim/abbrevs.vim

В начале редактирования нового файла, вы можете попросить Vim вставить в буфер
указанный вами шаблон-заготовку: >

	:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c

Полный список событий смотрите в |автокоманды-события|.


ШАБЛОНЫ

Аргумент {шаблон_имени_файла} может также представлять собой разделённый
запятыми список шаблонов имени. Например, "*.c,*.h" соответствует всем файлам,
имена которых заканчиваются на ".c" и ".h".
   Вы можете применять обычные символы-маски. Вот наиболее часто употребляемые
из них:

	*		Соответствует любому символу любое количество раз
	?		Соответствует любому символу один раз
	[abc]		Соответствует символу a, b или c
	.		Соответствует точке
	a{b,c}		Соответствует "ab" и "ac"

Если в шаблоне используется прямая косая черта (/), то Vim будет также
сравнивать указанные каталоги. Без указания косой черты ищется соответствие
только для самого имени файла. Например, "*.txt" соответствует
"/home/biep/readme.txt". Этому файлу также соответствует и "/home/biep/*", но
не "home/foo/*.txt".
   При использовании косой черты Vim будет определять соответствия как для
абсолютных путей к файлу (например "/home/biep/readme.txt"), так и для
относительных ("biep/readme.txt").

	Замечание:
	При работе в системе, которая использует в качестве разделителя
	каталога в путях к файлу обратную косую черту, например в MS-Windows,
	вам все равно необходимо использовать в автокоманде символ прямой
	косой черты. Это не только позволяет упростить написание шаблона, в
	котором обратная косая черта имеет особое значение, но и позволяет
	пользоваться такими автокомандами также и на других системах.


УДАЛЕНИЕ

Для удаления автокоманды используйте ту же команду, что и для определения с
аргументом ! и пустой {командой}. Пример: >

	:autocmd! FileWritePre *

По этой команде будут удалены все автокоманды для события "FileWritePre",
которые используют шаблон "*" для задания имени файла.


СПИСОК

Чтобы посмотреть список определённых в текущий момент автокоманд, используйте
команду: >

	:autocmd

Список может оказаться довольно длинным, особенно если используется
определение типа файла. Чтобы показать частичный список автокоманд,
используйте в качестве аргумента группу, событие и/или шаблон. Например, чтобы
показать список всех автокоманд для события BufNewFile: >

	:autocmd BufNewFile

А эта команда покажет список всех автокоманд для шаблона "*.c": >

	:autocmd * *.c

Использование "*" вместо события позволяет показать все события. Чтобы
посмотреть список автокоманд в группе cprograms: >

	:autocmd cprograms


ГРУППЫ

{группа} в определении автокоманды используется для группировки схожих
автокоманд. Это может быть использовано, например, для удаления всех
автокоманд, которые принадлежат одной группе.
   При определении нескольких автокоманд, которые принадлежат к одной группе,
используйте команду ":augroup". В качестве примера, давайте определим
автокоманды, которые будут использоваться для программ на языке C: >

	:augroup cprograms
	:  autocmd BufReadPost *.c,*.h :set sw=4 sts=4
	:  autocmd BufReadPost *.cpp   :set sw=3 sts=3
	:augroup END

Это эквивалентно описанию >

	:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4
	:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3

Для удаления всех автокоманд в группе "cprograms": >

	:autocmd! cprograms


ВЛОЖЕННЫЕ АВТОКОМАНДЫ

Обычно команды, которые выполняются в результате выполнения какой-либо
автокоманды, не приводят к возникновению новых событий. Если вы читаете файл
по событию FileChangedShell, то это не будет приводить к выполнению других
автокоманд, которые, например, настраивали бы для этого файла правила
синтаксиса. Чтобы такие события всё же происходили, то используйте флаг
"nested": >

	:autocmd FileChangedShell * nested  edit


ВЫПОЛНЕНИЕ АВТОКОМАНД

Автокоманду можно также заставить выполняться лишь делая вид, что то или иное
событие произошло. Это полезно в ситуации, когда одна автокоманда выполняет
другую. Например: >

	:autocmd BufReadPost *.new  execute "doautocmd BufReadPost " . expand("<afile>:r")

В данном случае определяется автокоманда, которая начинает выполняться как
только для редактирования открывается новый файл с именем, оканчивающимся на
".new". Команда ":execute" вычисляет выражение для определения другой команды,
которая также будет выполнена. Если вы открываете для редактирования файл
"tryout.c.new", то будет выполняться команда: >

	:doautocmd BufReadPost tryout.c

Функция expand() принимает аргумент "<afile>", значением которого является имя
файла, для которого выполняется автокоманда, и отсекает от имени файла
расширение при помощи ":r".

":doautocmd" выполняется в текущем буфере. Команда ":doautoall" работает так
же, как и ":doautocmd", за исключением того, что она выполняется на всех
буферах.


ИСПОЛЬЗОВАНИЕ КОМАНД ОБЫЧНОГО РЕЖИМА

Команды, которые выполняются автокомандой, являются командами, используемыми в
командной строке. Если вам необходимо использовать команду Обычного режима, то
воспользуйтесь командой ":normal". Например: >

	:autocmd BufReadPost *.log normal G

Это позволяет перевести курсор в конец файла с расширением .log при его
открытии в редакторе.
   Использование команды ":normal" требует немного ловкости. Прежде всего,
убедитесь, что аргумент этой команды является законченной командой обычного
режима, включая все возможные аргументы. Если вы используете для перехода в
режим Вставки команду "i", то следите за тем, чтобы не забыть указать <Esc>
для выхода из режима Вставки. Если вы используете команду "/" для выполнения
поиска по шаблону, то не забудьте также указать <CR>, чтобы команда поиска
могла быть выполнена. 
   Команда ":normal" использует весь текст, который следует после неё в
качестве аргумента-команды. Поэтому, в этой команде не может использоваться |
с последующей новой командой. Чтобы обойти это ограничение, используйте
команду ":normal" внутри команды ":execute". Это также позволяет удобно
передавать команде непечатные символы. Пример: >

	:autocmd BufReadPost *.chg execute "normal ONew entry:\<Esc>" |
		\ 1read !date

Этот пример также демонстрирует использование обратной косой черты для
разбивки длинной команды на несколько строк. Это можно использовать в
сценариях Vim, но не в самой командной строке.

Если вы хотите, чтобы автокоманда выполняла ряд сложных действий, включающих
перемещение внутри файла и возврат в исходную позицию, то вам возможно
подойдёт восстановление вида файла. См. в качестве примера
|восстановление_позиции|.


ПРОПУСК СОБЫТИЙ

Иногда возникают ситуации, когда вам, наоборот, хотелось бы не выполнять
никаких автокоманд при наступлении определённых событий. Опция 'eventignore'
позволяет настроить список событий, которые будут игнорироваться. Например,
следующая команда позволяет игнорировать события перемещения в окно и выхода
из окна с точки зрения отработки автокоманд: >

	:set eventignore=WinEnter,WinLeave

Чтобы игнорировать все события, используйте команду: >

	:set eventignore=all

Для восстановления нормального поведения, очистите опцию 'eventignore': >

	:set eventignore=

==============================================================================

Следующая глава: |usr_41.txt|  Написание сценариев Vim
Авторские права: см. |авторские_права_на_документацию|  

vim:tw=78:ts=8:ft=help:norl:
