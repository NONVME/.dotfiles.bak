*insert.txt*    Для Vim version 6.3.  Последнее изменение: 2004 Apr 09


		      СПРАВОЧНИК ПО VIM - Брам Мооленаар


					*Insert* *Insert-mode* *режим_вставки*
								     *Вставка*
Вставка и замена текста		      *mode-ins-repl* *режим_вставки_и_замены*

Этот документ в основном посвящен режимам Вставки и Замены. В конце также
рассматривается несколько альтернативных способов вставки текста.

С обзором наиболее часто используемых в этих режимах команд можно
познакомиться в главе 24 руководства пользователя |usr_24.txt|.

1.  Специальные кнопки				|вставка-специальные_кнопки|
2.  Специальные спецкнопки			|вставка-спец-спец|
3.  Опции 'textwidth' и 'wrapmargin'		|вставка-textwidth|
4.  Опции 'expandtab', 'smarttab' и		|вставка-expandtab|
    'softtabstop'        
5.  Режим Замены				|режим_замены|
6.  Режим Виртуальной Замены 		        |режим_виртуальной_замены|
7.  Автодополнение в режиме Вставки		|вставка-автодополнение|
8.  Команды режима Вставки			|вставка|
9.  Команды вставки Ex 			        |вставка-ex|
10. Вставка содержимого файла                   |вставка-файла|

Кроме того, полезно ознакомиться со справкой по опции 'virtualedit', которая
позволяет перемещать курсор в те позиции, где отсутствуют символы, что
особенно полезно при редактировании таблиц.

==============================================================================
1. Специальные кнопки	       *ins-special-keys* *вставка-специальные_кнопки*

В режимах Вставки и Замены некоторые символы имеют особое значение; другие
символы вставляются в текст как есть. Для того, чтобы вставить в буфер один из
таких специальных символов, его необходимо предварять нажатием CTRL-V. Для
вставки символа <Nul>, например, можно использовать "CTRL-V CTRL-@" или
"CTRL-V 000". На некоторых системах для вставки символа CTRL-C следует ввести
"CTRL-C 003". Замечание: если CTRL-V используется в привязках, то зачастую
можно использовать также CTRL-Q |i_CTRL-Q|.

Если при вставке текста вы используете какой-либо другой язык, то может
оказаться полезным ознакомиться с опцией 'langmap', которая позволяет избежать
постоянного переключения языка при работе в Vim.

При включённой опции 'insertmode' <Esc> и ряд других кнопок приобретают особое
значение. Подробнее см. |'insertmode'|.

символ		действие	~
------------------------------------------------------------------------------
						          *i_CTRL-[* *i_<Esc>*
<Esc> или CTRL-[
		Завершает режим вставки или замены и возвращает редактор в
		Обычный режим. Также завершает сокращение.
		Замечание: Если нажатие <Esc> кажется вам неудобным, можно
		также использовать CTRL-[.
						                    *i_CTRL-C*
CTRL-C		Прекращает режим вставки и возвращает редактор в Обычный
		режим, но не проверяет сокращения.

						                    *i_CTRL-@*
CTRL-@		Вставка текста, который был вставлен до этого и прекращение
		режима вставки. {Vi: только если введён в качестве первого
		символа и не более 128 символов}
		
						                    *i_CTRL-A*
CTRL-A		Вставка текста, который был вставлен до этого. 
		{Vi не имеет такой возможности}

			                            *i_CTRL-H* *i_<BS>* *i_BS*
<BS> или CTRL-H	Удаление символа, находящегося перед курсором (см. подробнее в
		|i_удаление_перед_курсором| об объединении строк).
		См. также |:fixdel|, если кнопка <BS> работает не так, как
		ожидается.
		{Vi: не удаляет автоматические отступы}
		
						             *i_<Del>* *i_DEL*
<Del>		Удаление символа, находящегося в позиции курсора. Если курсор
		находится в конце строки, а в списке значений опции
		'backspace' присутствует "eol", то будет удалён символ <EOL> и
		к данной строке будет добавлена следующая строка.
		См. также |:fixdel|, если кнопка <Del> работает не так, как
		ожидается.
		{Vi не имеет такой возможности}
						
						                    *i_CTRL-W*
CTRL-W		Удаление слова перед курсором (см. подробнее в
		|i_удаление_перед_курсором| об объединении строк). См. также
		определение слова в разделе "перемещения по словам"
		|перемещения-по_словам|.

						                    *i_CTRL-U*
CTRL-U		Удаление всех введённых символов на текущей строке (см.
		подробнее в |i_удаление_перед_курсором| об объединении строк).

						  *i_CTRL-I* *i_<Tab>* *i_Tab*
<Tab> или CTRL-I 
		Вставка символа табуляции. При включённой опции 'expandtab'
		будет вставлено соответствующее количество пробелов (чтобы
		избежать замены табуляции пробелами в этом случае используйте
		CTRL-V <Tab>; если же CTRL-V используется в привязках, то
		используйте CTRL-Q <Tab> |i_CTRL-Q|). См. также справку по
		опции 'smarttab' и раздел |вставка-expandtab|.

						           *i_CTRL-J* *i_<NL>*
<NL> или CTRL-J	Начать новую строку.
						           *i_CTRL-M* *i_<CR>*
<CR> или CTRL-M	Начать новую строку.
						                    *i_CTRL-K*
CTRL-K {симв1} [симв2]
		Вставить диграф (см. |диграфы|). Если {симв1} является
		специальной кнопкой, то будет вставлен код этого символа в
		виде <>. Например, строка "<S-Space>" может быть вставлена
		путём нажатия двух кнопок <C-K><S-Space>. Символы не
		проверяются на наличие привязок.
		{Vi не имеет такой возможности}

CTRL-N		Найти следующее ключевое слово (см. |i_CTRL-N|).
		{Vi не имеет такой возможности}

CTRL-P		Найти предыдущее ключевое слово (см. |i_CTRL-P|).
		{Vi не имеет такой возможности}

CTRL-R {0-9a-z"%#*+:.-=}					    *i_CTRL-R*
		Вставить содержимое регистра. После ввода CTRL-R и перед
		вводом второго символа будет отображаться символ '"', чтобы
		было ясно, что редактор ожидает ввода имени регистра.
		Текст вставляется так, как если бы он был набран вручную, за
		исключением привязок и сокращений, которые не используются.
		Текст, который вставляется в буфер из регистра, может зависеть
		от значения опций 'textwidth', 'formatoptions',	'autoindent' и
		т.п. В этом проявляется отличие от вставки текста по команде
		"p" или с помощью мыши.

		Специальные регистры:

			'"'	безымянный регистр, содержащий последний
				удалённый или скопированный фрагмент текста
			'%'	текущее имя файла
			'#'	имя соседнего файла
			'*'	содержимое буфера обмена (X11: основное
				выделение)
			'+'	содержимое буфера обмена
			'/'	шаблон последнего поиска
			':'	последняя команда из командной строки
			'.'	последний вставленный текст
			'-'	последнее незначительное (меньше строки)
				удаление
			'='	регистр выражения: перед завершением вставки
				выдаётся приглашение для ввода выражения
				(см. |выражение|)

		Подробнее о регистрах см. |регистры|.
		{Vi не имеет такой возможности}

CTRL-R CTRL-R {0-9a-z"%#*+/:.-=}			     *i_CTRL-R_CTRL-R*
		Вставить содержимое регистра. Эта команда работает аналогично
		одиночному CTRL-R, но содержимое регистра вставляется
		буквально, а не так, как набрано. Отличие становится заметным,
		если в регистре содержатся символы наподобие <BS>. Например,
		если в регистре a хранится строка "ab^Hc": >
		
		CTRL-R a	    приводит к вставке "ac".
		CTRL-R CTRL-R a	    приводит к вставке "ab^Hc".
<
		Опции 'textwidth', 'formatoptions' и т.д. оказывают точно
		такое же влияние как и в случае одинарной команды CTRL-R. Если
		вам необходимо игнорировать эти опции при вставке, то следует
		использовать "<C-R><C-O>r" (см. ниже). Регистр "." (последний
		вставленный текст) всегда вставляется так, как он был набран.
		{Vi не имеет такой возможности}

CTRL-R CTRL-O {0-9a-z"%#*+/:.-=}			     *i_CTRL-R_CTRL-O*
		Вставить содержимое регистра буквально и без автоматического
		форматирования отступов. Полностью аналогично вклейке текста
		при помощи средней кнопки мыши |<MiddleMouse>|.
		Эта операция не заменяет символы!
		Регистр "." (последний вставленный текст) всегда вставляется
		так, как он был набран.
		{Vi не имеет такой возможности}

CTRL-R CTRL-P {0-9a-z"%#*+/:.-=}			     *i_CTRL-R_CTRL-P*
		Вставить содержимое регистра буквально с восстановлением
		правильного автоматического форматирования отступов, как при
		помощи средней кнопки мыши |<MiddleMouse>|.
		Эта операция не заменяет символы!
		Регистр "." (последний вставленный текст) всегда вставляется
		так, как он был набран.
		{Vi не имеет такой возможности}

						                    *i_CTRL-T*
CTRL-T		Вставить один отступ перед началом текущей строки. Величина
		отступа всегда округляется до значения опции 'shiftwidth' (для
		совместимости с vi).
		{Vi: работает только если курсор находится на самом отступе}
						
						                    *i_CTRL-D*
CTRL-D		Удалить один отступ в начале текущей строки. Величина
		отступа всегда округляется до значения опции 'shiftwidth' (для
		совместимости с vi).
		{Vi: CTRL-D работает только после применения автоматического
		форматирования отступов}

						                  *i_0_CTRL-D*
0 CTRL-D	Удалить все отступы в текущей строке.
		{Vi: CTRL-D работает только после применения автоматического
		форматирования отступов}

						                  *i_^_CTRL-D*
^ CTRL-D	Удалить все отступы в текущей строке. Отступы
		восстанавливаются в следующей строке. Это полезно при вставке
		метки.
		{Vi: CTRL-D работает только после применения автоматического
		форматирования отступов}

						                    *i_CTRL-V*
CTRL-V		Вставить следующий нецифровой символ буквально. В случае
		специальных кнопок вставляется код терминала. Кроме того,
		можно ввести десятичный, восьмеричный или шестнадцатеричный
		код символа |i_CTRL-V_цифра|.
		Символы, введённые непосредственно сразу после CTRL-V не
		проверяются на использование в привязках. {Vi: отсутствует
		ввод десятичного байтового кода}
		Замечание: Если CTRL-V задействовано в привязках (например,
		для вклейки текста), то часто можно вместо CTRL-V использовать
		CTRL-Q |i_CTRL-Q|.

						                    *i_CTRL-Q*
CTRL-Q		То же, что и CTRL-V.
		Замечание: некоторые терминалы могут "проглатывать" CTRL-Q, и
		в этом случае CTRL-Q работать не будет. CTRL-Q не работает в
		графическом интерфейсе.

CTRL-X		Переход в режим CTRL-X. Это специальный дополнительный режим,
		в котором можно выполнять команды для автоматического
		дополнения слов или прокрутки окна. См. |i_CTRL-X| и
		|вставка-автодополнение|.
		{Vi не имеет такой возможности}

						                    *i_CTRL-E*
CTRL-E		Вставить символ, находящийся под курсором.
		{Vi не имеет такой возможности}

						                    *i_CTRL-Y*
CTRL-Y		Вставить символ, находящийся над курсором.
		{Vi не имеет такой возможности}

		Замечание: значение опции 'textwidth' в командах CTRL-E и
		CTRL-Y не используется, чтобы сохранить возможность
		копирования символов из длинной строки.

						                    *i_CTRL-_*
CTRL-_		Переключение между языками с различным направлением текста
		следующим образом:
		-  в окне с текстом "справа налево" переключаются опции revins
		   и nohkmap, поскольку наиболее вероятно, что далее будет
		   введён текст на английском.
	        -  в окне с текстом "слева направо" переключаются опции revins
		   и hkmap, поскольку наиболее вероятно, что далее будет
		   введён текст на иврите.

		CTRL-_ перемещает курсор в конец введённого текста.

		Команда доступна только в том случае, если включена опция
		'allowrevins'.
		Более подробную информацию о режиме ввода текста "справа
		налево" читайте в |rileft.txt|.
		{Vi не имеет такой возможности}
		
		Команда доступна только в том случае, если Vim собран со
		включённой особенностью |+rightleft| (по умолчанию эта
		особенность выключена).
						
						                    *i_CTRL-^*
CTRL-^		Переключение между раскладками различных языков.
		Если определены раскладки клавиатуры для языков при помощи
		команды |:lmap|:
		
		- В том случае, если значение опции 'iminsert' равняется 1
		  (используется раскладка клавиатуры), оно заменяется на 0
		  (раскладка клавиатуры не используется).
		- В том случае, если 'iminsert' имеет какое-либо другое
		  значение, оно заменяется на 1; таким образом, включается
		  раскладка клавиатуры для другого языка.

		Если раскладки клавиатуры для языка не определены:

		- В том случае, если значение опции 'iminsert' равняется 2
		  (используется Метод Ввода), оно заменяется на 0 (Метод Ввода
		  не используется).
		- В том случае, если опция 'iminsert' имеет какое-либо другое
		  значение, оно заменяется на 2; таким образом, включается
		  использование Метода Ввода.
		
		При значении опции 'iminsert' равном 1 в строке состояния
		появляется значение переменной "b:keymap_name", либо значение
		опции 'keymap', либо "<lang>". Раскладка клавиатуры как
		правило используется для ввода альтернативных символов. При
		помощи опции 'keymap' можно устанавливать различные
		дополнительные раскладки клавиатуры.
		{Vi не имеет такой возможности}

						                    *i_CTRL-]*
CTRL-]		Подставить значение (полный вариант) сокращения без вставки
		символа.
		{Vi не имеет такой возможности}

						                  *i_<Insert>*
<Insert>	Переключение между режимами Вставки и Замены.
		{Vi не имеет такой возможности}
------------------------------------------------------------------------------

		                   *i_backspacing* *i_удаление_перед_курсором*
Действие кнопок <BS>, CTRL-W и CTRL-U зависит от значения опции 'backspace'
(за исключением тех случаев, когда включена опция 'revins'). Значением этой
опции служит список ключевых слов, разделённых запятой:

слово	    действие ~
------------------------------------------------------------------------------
indent	    разрешает удаление автоматических отступов, расположенных перед
	    курсором
eol	    разрешает удаление символа конца строки перед курсором (объединяет
	    две строки в одну)
start	    разрешает удаление символов перед курсором, расположенных до
	    начала вставки: CTRL-W и CTRL-U прекращают удаление при достижении
	    начальной позиции вставки.
------------------------------------------------------------------------------

Если значением опции 'backspace' является пустая строка, то используется
Vi-совместимое удаление предыдущих символов. При этом нельзя удалять символы
автоматических отступов, символы перед первой колонкой текста, а также
символы, расположенные до начальной позиции вставки.

Для совместимости c предыдущими версиями также допускаются значения "0", "1" и
"2", см. |'backspace'|.

Если в списке значений опции 'backspace' содержится "eol", а курсор находится
в колонке 1, то при использовании одной из указанных выше трёх кнопок текущая
строка объединяется с предыдущей, при этом удаляется символ <EOL>,
расположенный перед курсором.
{Vi не позволяет командам удаления предыдущего символа пересекать границы
строк, а также не позволяет удалять символы, расположенные перед началом
вставки}

					     *i_CTRL-V_digit* *i_CTRL-V_цифра*
При помощи CTRL-V можно также напрямую вводить десятичное, восьмеричное или
шестнадцатеричное значение символа. Используя этот способ можно ввести любой
символ, за исключением символа переноса строки (<NL>, 10). Для ввода числового
значения символа предусмотрено пять способов:

первый символ	режим	          макс. кол-во          макс. значение ~
                                     символов  ~
------------------------------------------------------------------------------
(нет)		десятичный		3		     255
o или O		восьмеричный		3		     255
x или X		шестнадцатеричный	2		  ff (255)
u		шестнадцатеричный	4		ffff (65535)
U		шестнадцатеричный	8	    7fffffff (2147483647)
------------------------------------------------------------------------------

После ввода CTRL-V обычно следует вводить максимальное количество цифр.
Например, чтобы ввести пробел (код 32) требуется набрать <C-V>032.
Предшествующие нули можно опустить, но в этом случае сразу после необходимого
числа должен идти нецифровой символ. То же самое можно сказать и о других
режимах: как только вводится символ, который не должен присутствовать в числе
в данном режиме, используется код, выраженный уже введённым числом, а
"неправильный" символ вставляется в текст уже обычным образом.

Если вы введёте значение 10, то вместо него в файл будет вставлен символ с
кодом 0. Дело в том, что внутри Vim символ <NL> (код 10) используется для
представления символа <Nul>. При записи буфера в файл символы <NL> переводятся
в символы <Nul>. Символ <NL> записывается в конце каждой строки, поэтому для
вставки символа <NL> необходимо воспользоваться переносом строки.

			      *i_CTRL-X* *insert_expand* *вставка_расширенная*
Нажатие CTRL-X переводит редактор в специальный дополнительный режим, в
котором можно использовать несколько специальных команд. Большая часть этих
команд предназначена для выполнения дополнения слов; подробнее см.
|вставка-автодополнение|. Этот режим доступен только в Vim, скомпилированным с
включённой особенностью |+insert_expand|.

Также доступны две команды для прокрутки окна вверх или вниз без выхода из
режима вставки:

						             *i_CTRL-X_CTRL-E*
CTRL-X CTRL-E		прокрутка окна на одну строку вверх.

						             *i_CTRL-X_CTRL-Y*
CTRL-X CTRL-Y		прокрутка окна на одну строку вниз.

После нажатия CTRL-X каждое последующее нажатие CTRL-E (CTRL-Y) позволяет
прокручивать окно вверх (вниз) на одну строку до тех пор, пока прокрутка не
вызывает перемещения курсора внутри файла. Режим CTRL-X прекращается при
нажатии любой другой кнопки, которая передаётся в редактор как если бы она
была нажата в режиме Вставки.

==============================================================================
2. Специальные спецкнопки            *ins-special-special* *вставка-спец-спец*

Обсуждаемые в этом разделе кнопки имеют одну специальную особенность. Все они
прекращают текущую вставку, выполняют то или иное действие, и затем вставка
возобновляется. Это позволяет выполнять те или иные действия не покидая режим
Вставки, что особенно полезно в тех случаях, когда вы предпочитаете
пользоваться режимом Вставки постоянно, как в редакторах, в которых нет
отдельного Обычного режима. В этом случае также может быть полезным установить
значение опции 'backspace' равным "indent,eol,start" и включить опцию
'insertmode'. Если вы хотите привязать какую-нибудь функциональную кнопку к
команде, воспользуйтесь CTRL-O.

Изменения (вставленные и удалённые символы), произошедшие до и после нажатия
на эти кнопки, могут быть отменены по отдельности. Повторное выполнение
отменённой операции применимо только к последнему изменению и всегда работает
как команда "i".

символ		действие	~
------------------------------------------------------------------------------
<Up>		курсор на одну строку вверх		              *i_<Up>*
<Down>		курсор на одну строку вниз		            *i_<Down>*
CTRL-G <Up>	курсор на одну строку вверх,                   *i_CTRL-G_<Up>*
                вставка в начале колонки
CTRL-G k	курсор на одну строку вверх, 	                  *i_CTRL-G_k*
                вставка в начале колонки
CTRL-G CTRL-K	курсор на одну строку вверх, 	              *i_CTRL-G_CTRL-K*
		вставка в начале колонки
CTRL-G <Down>	курсор на одну строку вниз,                   *i_CTRL-G_<Down>*
		вставка в начале колонки
CTRL-G j	курсор на одну строку вниз,                        *i_CTRL-G_j*
		вставка в начале колонки
CTRL-G CTRL-J	курсор на одну строку вниз,                   *i_CTRL-G_CTRL-J*
		вставка в начале колонки
<Left>		курсор на один символ влево		             *i_<Left>*
<Right>		курсор на один символ вправо		            *i_<Right>*
<S-Left>	курсор на одно слово назад (как команда "b")	   *i_<S-Left>*
<C-Left>	курсор на одно слово назад (как команда "b")       *i_<C-Left>*
<S-Right>	курсор на одно слово вперёд (как команда "w")     *i_<S-Right>*
<C-Right>	курсор на одно слово вперёд (как команда "w")     *i_<C-Right>*
<Home>		курсор к первому символу строки	                     *i_<Home>*
<End>		курсор после последнего символа строки	              *i_<End>*
<C-Home>	курсор к первому символу в файле	           *i_<C-Home>*
<C-End>		курсор после последнего символа в файле	            *i_<C-End>*
<LeftMouse>	курсор в позицию нажатия на левую кнопку мыши   *i_<LeftMouse>*
<S-Up>		курсор на одну страницу вверх                        *i_<S-Up>*
<PageUp>	курсор на одну страницу вверх 		           *i_<PageUp>*
<S-Down>	курсор на одну строку вниз		           *i_<S-Down>*
<PageDown>	курсор на одну строку вниз                       *i_<PageDown>*
<MouseDown>	прокрутка на три строки вниз	                *i_<MouseDown>*
<S-MouseDown>	прокрутка на страницу вниз 		      *i_<S-MouseDown>*
<MouseUp>	прокрутка на три строки вверх		          *i_<MouseUp>*
<S-MouseUp>	прокрутка на страницу вверх                     *i_<S-MouseUp>*
CTRL-O		выполнить одну команду и вернуться в режим Вставки   *i_CTRL-O*
CTRL-G u        прервать последовательность отмен                   *i_CTRL-G_u*
                и начать новую последовательность изменений
------------------------------------------------------------------------------

Замечание: Если кнопки курсора прекращают режим Вставки, проверьте значение
опции 'noesckeys'.

Команда CTRL-O может иметь побочный эффект: если курсор находится за последним
символом строки, то он будет перемещён к последнему символу в этой строке. 
В привязках зачастую лучше использовать <Esc> (сначала поместите в текст "x",
в этом случае <Esc> всегда будет перемещать курсор на это место).

<Shift> с кнопками курсора работает не на всех терминалах.

Другим побочным эффектом является то обстоятельство, что число, выступающее
аргументом для команд "i" и "a", игнорируется. Это связано с тем, что
повторение такой команды после CTRL-O становится слишком сложным.

Пример использования команды CTRL-G u: >

	:inoremap <C-H> <C-G>u<C-H>
>
Указанная выше привязка переопределяет действие кнопки удаления символа слева
от курсора так, что при этом начинается новая последовательность изменений.
Теперь вы можете отменить эффект нажатия кнопки удаления символа слева от
курсора без внесения изменений в набранный раннее текст по команде CTRL-O u.

При соответствующих настройках опции 'whichwrap' кнопки <Left> и <Right> на
первом/последнем символе строки могут переносить курсор на
предыдущую/последующую строку.

Команды CTRL-G j и CTRL-G k могут использоваться для вставки текста в начале
колонки. Например: >

   int i;
   int j;
   
Поместите курсор на первом слове "int" и наберите "istatic<C-G>j       ".
Результат будет таким: >
 
   static int i;
	  int j;

При вставке того же самого текста перед колонкой в каждой строке можно
использовать команду "I" в Визуальном блоковом режиме |v_b_I|.

==============================================================================
3. Опции 'textwidth' и 'wrapmargin'	   *ins-textwidth* *вставка-textwidth*

Опция 'textwidth' может использоваться для автоматического переноса строки,
если та становится слишком длинной. Значением опции 'textwidth' является
желательная максимальная длина строки. Если вы введёте больше символов, чем
значение этой опции, исключая символы пробела и табуляции, то последнее
набранное слово будет перенесено на новую строку, за исключением того случая,
когда это единственное слово в строке. Такое поведение можно отключить, если
установить значение опции 'textwidth' равным 0.

Опция 'wrapmargin' делает почти то же самое. Различие заключается в том, что
опция 'textwidth' устанавливает фиксированную максимальную ширину строки, а
при использовании опции 'wrapmargin' ширина строки зависит от ширины экрана.
Использование опции 'wrapmargin' эквивалентно использованию опции 'textwidth'
со значением, равным (числу колонок окна - 'wrapmargin').

Если значения обеих опций 'textwidth' и 'wrapmargin' не равны нулю, то
используется значение опции 'textwidth'.

В том случае, когда вам на самом деле нежелательно переносить строки, но
хотелось бы только просматривать текст с переносом длинных строк, используйте
опцию 'linebreak'.

Строка переносится автоматически только в режиме вставки или при добавлении
текста к строке. В режиме замены строка не переносится, если её длина остаётся
неизменной.

Длинные строки переносятся при вводе непробельного символа за пределами
установленной ширины. Ситуации, в которых перенос строки может быть ограничен,
определяются символами в значении опции 'formatoptions':

"l"  Переносить строку только в том случае, если она была не длиннее значения
     'textwidth' во время начала вставки.
"v"  Переносить строку только на пробелах, введённых во время текущей вставки
     текста. Это наиболее Vi-совместимый режим переноса строк.
"lv" Переносить строку только в том случае, если длина строки была меньше
     значения 'textwidth' в момент начала вставки текста и только на
     пробельных символах, введённых после начала текущей вставки. Отличается
     от "l" только при вводе непробельных символов, выходящих за границу поля,
     установленного 'textwidth'.

Для форматирования блока текста можно использовать оператор "gq". Наберите
команду "gq" и воспользуйтесь одной из команд перемещения для переноса курсора
в конец блока, который следует отформатировать. В большинстве случаев
достаточно ввести команду "gq}" (форматировать текст до конца абзаца). Также
можно использовать команду "gqap", которая позволяет выполнять форматирование
целого абзаца, независимо от позиции курсора. Также можно воспользоваться
Визуальным режимом: ввести команду "v", переместить курсор в конец блока и
затем набрать "gq". См. также |gq|.

==============================================================================
		                                               *ins-expandtab*
4. Опции 'expandtab', 'smarttab' и 'softtabstop'           *вставка-expandtab*

При включённой опции 'expandtab' при вводе символа табуляции в буфер
вставляется необходимое число пробелов вместо символа <Tab>. Чтобы ввести
настоящий <Tab> в этом случае, введите перед символом табуляции CTRL-V (или
CTRL-Q, если CTRL-V используется в привязках |i_CTRL-Q|).

По умолчанию опция 'expandtab' выключена. Замечание: в режиме Замены один
символ при этом заменяется на несколько. В результате количество символов в
строке увеличивается. Кнопка удаления предыдущего символа будет возвращать по
одному пробелу за один раз. Первоначальный символ будет возвращён на место
только в случае последнего пробела.
{Vi не имеет опции 'expandtab'}

					     *ins-smarttab* *вставка-smarttab*
При включённой опции 'smarttab', кнопка <Tab> вставляет пробелы в количестве,
указанном в значении опции 'shiftwidth' в начале строки, и пробелы в
количестве, указанном в значении опции 'tabstop' во всех остальных местах. Это
приводит к тому, что часто вместо символа <Tab> на самом деле будут вставлены
символы пробела. При отключенной опции 'smarttab', кнопка <Tab> всегда
вставляет пробелы так, как указано в значении опции 'tabstop', а значение
опции 'shiftwidth' используется только для команд вроде ">>".
{Vi не имеет такой возможности}


				       *ins-softtabstop* *вставка-softtabstop*
Если значение опции 'softtabstop' не равно нулю, при нажатии на кнопку <Tab>
происходит вставка пробелов в количестве, указанном в значении опции
'softtabstop', и кнопка <BS> будет также удалять пробелы в этом же количестве.
Это выглядит, как если бы значение опции 'tabstop' было равно значению опции
'softtabstop', но при этом символ <Tab> будет в любом случае занимать столько
пробелов, сколько указано в значении опции 'tabstop', поэтому файл будет
выглядеть одинаково во всех приложениях.

Если значение опции 'softtabstop' не равно нулю, то кнопка <BS> будет удалять
максимально возможное количество пробелов, необходимое для перехода к
предыдущей позиции, определяемой значением опции 'softtabstop', за исключением
тех случаев, когда символ, вставленные непосредственно перед этим являлся
пробелом - в этом случае будет удалён только пробел, находящийся
непосредственно перед курсором. Иначе говоря, вам не всегда удастся удалить
единственный пробел перед курсором, в некоторых ситуациях вам придётся сначала
удалить пробелы в количестве, указанном в значении опции 'softtabstop', а
затем заново ввести необходимое количество пробелов.


==============================================================================
					               *Замена* *режим_замены*
5. Режим Замены                        *Replace* *Replace-mode* *mode-replace*

Для перехода в режим Замены из Обычного режима пользуйтесь командой "R".

В режиме Замены ввод символов осуществляется "поверх" существующего текста, с
одновременным удалением уже набранных символов. Если в тексте больше нет
символов, которые надо заменить, например, в конце строки, то вводимые символы
просто добавляются к уже набранным, как в режиме Вставки. Таким образом,
количество символов в строке остаётся неизменным, пока вы не доберётесь до
конца строки. При вводе символа новой строки <NL> происходит вставка переноса
строки без удаления существующих символов.

Будьте осторожны с символами табуляции <Tab>. Если вместо символа табуляции вы
введёте обычные печатные символы, то количество символов останется неизменным,
хотя количество колонок в строке будет уже меньше.

При удалении символов в режиме Замены (с помощью <BS>, <CTRL-W> или <CTRL-U>),
фактически происходит удаление внесённых изменений. Символы, которые были
изменены восстанавливаются к исходному состоянию. Если вы ввели больше
символов, чем было в строке раннее, то лишние символы удаляются. Таким
образом, режим Замены может быть представлен как посимвольная отмена внесённых
изменений. 

При включённой опции 'expandtab', ввод символа <Tab> будет приводить к замене
одного символа на несколько пробелов. В силу этого количество символов в
строке будет больше. Нажатие кнопки <BS> приводит к удалению одного пробела за
раз. При этом восстанавливается только один исходный символ, а именно
последний.
{Vi не имеет опции 'expandtab'}

==============================================================================
						    *режим_виртуальной_замены*
6. Режим Виртуальной Замены	        *vreplace-mode* *Virtual-Replace-mode*

Для перехода в режим Виртуальной Замены из Обычного режима пользуйтесь
командой "gR".
{доступно только в том случае, если Vim скомпилирован с особенностью
+vreplace}
{Vi не имеет режима Виртуальной Замены}

Режим Виртуальной Замены очень похож на режим Замены, но вместо замены
символов в файле вы заменяете символы на экране, поэтому текст, который
находится в файле после курсора никогда никуда не смещается.

Например, кнопка <Tab> может заменять несколько обычных символов, а если вы
введёте букву поверх символа <Tab>, то возможно, что никакой замены не
произойдёт, поскольку символ <Tab> по прежнему будет выравниваться к той же
колонке, что и прежде.

Ввод символа новой строки <NL> не приводит к переносу символов, расположенных
далее по тексту в файле. Оставшиеся за курсором символы текущей строки будут
заменены (точнее, удалены), а замена будет продолжена на следующей строке.
Новая строка вставляется только в том случае, если вы достигните конца файла.

При использовании CTRL-T и CTRL-D в этом режиме можно достичь довольно
интересных эффектов. Символы, расположенные перед курсором сдвигаются как
обычно, а символы, расположенные после курсора остаются на месте. CTRL-T будет
скрывать набранные раннее символы под символами, затронутыми сдвигом, а CTRL-D
будет восстанавливать их на место. 

Как и в режиме Замены, использование кнопок типа <BS> приводит к
восстановлению символов, которые были заменены перед этим. То же самое будет
происходить и в сочетании с опцией 'smartindent', CTRL-T и CTRL-D, опциями
'expandtab', 'smarttab', 'softtabstop' и т.п.

При установленной опции 'list' Виртуальная Замена работает так, как будто опция
'list' была отключена, за исключением ситуации, при которой в значении опции
'cpoptions' присутствует флаг "L".

Обратите внимание, что в этом режиме символы, расположенные после курсора,
могут смещаться только при включённой опции 'list', а также в некоторых
случаях при включённой опции 'wrap' (если строка изменяется таким образом, что
становится длиннее или короче, чем ширина экрана), а также временно при замене
символа, введённого с помощью CTRL, поскольку символ, введённый с помощью CTRL
занимает на экране два символа. При замене такого символа на два обычных
символа, первый будет вставлен, а второй заменит символ, введённый с помощью
CTRL.

Этот режим чрезвычайно полезен для редактирования колонок в таблицах,
разделённых символом <Tab>, при вводе новых данных, когда важно сохранить
выравнивание для всех колонок таблицы.

==============================================================================
7. Автодополнение в режиме Вставки   *ins-completion* *вставка-автодополнение*

В режимах Вставки и Замены имеется несколько специальных команд, позволяющих
дополнить часть ключевого слова или строки, которые были введены до этого. Это
полезно при использовании сложных ключевых слов (например, имён функций с
символами подчёркивания и заглавными буквами).

Эти команды доступны только в том случае, если Vim был скомпилирован с
особенностью |+insert_expand|.

Дополнение может быть осуществлено для:

1.  Целых строк						|i_CTRL-X_CTRL-L|
2.  Ключевых слов в текущем файле			|i_CTRL-X_CTRL-N|
3.  Ключевых слов в 'dictionary'			|i_CTRL-X_CTRL-K|
4.  Ключевых слов в 'thesaurus', в виде синонимов	|i_CTRL-X_CTRL-T|
5.  Ключевых слов в текущем и подключаемых файлах	|i_CTRL-X_CTRL-I|
6.  Меток						|i_CTRL-X_CTRL-]|
7.  Имён файлов						|i_CTRL-X_CTRL-F|
8.  Определений или макросов				|i_CTRL-X_CTRL-D|
9.  Командной строки Vim				|i_CTRL-X_CTRL-V|
10. Ключевых слов в 'complete'				|i_CTRL-N|

Все эти команды, за исключением 10, выполняются в специальном режиме CTRL-X.
Это подрежим режимов Вставки и Замены, переход в который происходит по нажатию
CTRL-X, после чего ожидается ввод одной из команд режима CTRL-X. Выход из
режима CTRL-X происходит при вводе символа, который не является командой
режима CTRL-X. К командам CTRL-X относятся сама команда CTRL-X, CTRL-N
(следующее) и CTRL-P (предыдущее).

Если вы желаете при этом поправить регистр символов соответствия, обратитесь к
справке для опции 'infercase'.

Замечание: кнопки, которые являются командами в режиме CTRL-X не
переопределяются в привязках. Это позволяет вводить команды вроде 
":map ^F ^X^F" (^F это CTRL-F, а ^X это CTRL-X). Кнопки, по которым происходит
выход из режима CTRL-X (т.е. те, которые не являются командами режима CTRL-X)
могут быть переопределены в привязках. Кроме того, при дополнении с помощью
'complete' привязки также работают как обычно.

Для более простого ввода команд дополнения можно использовать следующие
привязки (хотя, при этом они не смогут быть использованы в других командах): >

    :inoremap ^] ^X^]
    :inoremap ^F ^X^F
    :inoremap ^D ^X^D
    :inoremap ^L ^X^L

Особым случаем является вставка содержимого регистра по команде CTRL-R (см.
|i_CTRL-R|), при которой выхода из режима CTRL-X может и не происходить. Так
сделано в основном для того, чтобы позволить использование регистра '=' для
вызова какой-либо функции, которая бы определяла дальнейшие действия. Если
содержимое регистра (или результат вычисления регистра '=') не является
кнопкой режима CTRL-X, то произойдёт выход из этого режима, как если бы такая
команда была введена с клавиатуры. 

Например, ниже показано, как привязать <Tab> таким образом, чтобы при нажатии
на эту кнопку происходила вставка символа <Tab> в том случае, если текущая
строка состоит из одних пробелов, либо начать или продолжить операцию
дополнения с помощью CTRL-N: >

	function! CleverTab()
	   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
	      return "\<Tab>"
	   else
	      return "\<C-N>"
	endfunction
	inoremap <Tab> <C-R>=CleverTab()<CR>



Автодополнение целых строк     *compl-whole-line* *автодополнение_целых_строк*

							     *i_CTRL-X_CTRL-L*
CTRL-X CTRL-L		Поиск строки, которая начинается с тех же символов,
			что и текущая строка перед курсором в обратном
			направлении. Отступы игнорируются. Найденная строка
			вставляется перед курсором.
			Опция 'complete' используется для определения буферов,
			в которых происходит поиск соответствия. При этом
			используются только загруженные буферы.
	CTRL-L	или
	CTRL-P		Поиск следующего соответствия в обратном направлении.
			Найденная строка заменяет собой предыдущее
			соответствие.

	CTRL-N		Поиск следующего соответствия дальше по тексту.
			Найденная строка заменяет собой предыдущее
			соответствие.

	CTRL-X CTRL-L	После дополнения строки вы можете также вставить
			следующую за ней строку путём повторного нажатия
			CTRL-X CTRL-L, если при этом не используется двойное
			CTRL-X.

					    *автодополнение_из_текущего_файла*
Автодополнение ключевых слов в текущем файле                   *compl-current* 

							     *i_CTRL-X_CTRL-P*
							     *i_CTRL-X_CTRL-N*
CTRL-X CTRL-N		Поиск слова, начинающегося с символов перед курсором
			далее по тексту. Найденное ключевое слово вставляется
			перед курсором.

CTRL-X CTRL-P		Поиск слова, начинающегося с символов перед курсором
			в обратном направлении. Найденное ключевое слово
			вставляется перед курсором.

	CTRL-N		Продолжить поиск соответствия далее по тексту.
			Найденное ключевое слово заменяет предыдущее
			соответствие.

	CTRL-P		Продолжить поиск соответствия в обратном направлении.
			Найденное ключевое слово заменяет предыдущее
			соответствие.

	CTRL-X CTRL-N или
	CTRL-X CTRL-P	
			Дальнейшее использование CTRL-X CTRL-N или CTRL-X
			CTRL-P приводит к вставке слов, следующих за найденным
			перед этим соответствием, если при этом не
			используется двойное CTRL-X.

Если перед курсором находится ключевое слово (т.е. слово, состоящее из
символов алфавита и символов, описанных в значении опции 'iskeyword'), то оно
используется в качестве шаблона для поиска с добавлением приставки "\<" (т.е.,
начало слова). В противном случае для поиска используется шаблон с приставкой
"\<\k\k" (начало любого ключевого слова, состоящего как минимум из двух
символов).

В режиме Замены количество символов, которое будет заменено, зависит от длины
строки соответствия. Фактически, это работает точно так же, как если бы
символы строки соответствия были набраны в режиме Замены с клавиатуры вручную.

Если перед курсором нет символа, который может быть в составе ключевого слова,
то соответствием является любое ключевое слово, состоящее как минимум из двух
символов.

Например, чтобы получить: >
	
	printf("(%g, %g, %g)", vector[0], vector[1], vector[2]);
<
    достаточно набрать >

	printf("(%g, %g, %g)", vector[0], ^P[1], ^P[2]);
	

Повторы уже найденных соответствий пропускаются; при каждом нажатии CTRL-N и
CTRL-P будет подставляться новое соответствие (кроме случаев, когда имеется
только одно соответствие).

Соответствия из одного символа никогда не включаются, поскольку они обычно
только мешают искать то, что действительно необходимо.

Например, чтобы получить: >

	printf("name = %s\n", name);
<
    достаточно набрать: >

	printf("name = %s\n", n^P);

<   или даже: >

	printf("name = %s\n", ^P);

Таким образом, 'n' в '\n' будет пропущено.

После дополнения слова вы можете использовать CTRL-X CTRL-P или CTRL-X CTRL-N,
чтобы вставить следующее за дополнением слово в других контекстах. Это
позволяет быстро найти текст, который был только что дополнен и вставить
следующее слово. Это полезно, если вам необходимо повторить сложную
последовательность слов. Хотя CTRL-P и CTRL-N выполняют поиск слов, состоящих
как минимум из двух символов, CTRL-X CTRL-P и CTRL-X CTRL-N могут быть
использованы для вставки последующих слов, состоящих из одного символа.

Например, чтобы получить: >

	M&eacute;xico
<
    достаточно набрать: >

	M^N^P^X^P^X^P
<
    CTRL-N начинает дополнение, последующий ввод CTRL-P находит одиночный
    символ "M", последующие CTRL-X CTRL-P позволяют подставить слова "&eacute"
    и ";xico".
    

Если предыдущее дополнение было разбито на строки из-за того, что текст по
ширине не умещается в значение опции 'textwidth', то будет использоваться
текст в текущей строке.

Если найденное соответствие находится в конце строки, то будет вставлено
первое слово следующей за соответствием строки и будет выдано сообщение 
"Слово с другой строки". В случае принятия этого слова последующие команды
CTRL-X CTRL-P или CTRL-X CTRL-N будут осуществлять поиск строк, начинающихся с
данного слова.

						   *автодополнение_по_словарю*
Автодополнение слова в 'dictionary'                         *compl-dictionary*

							     *i_CTRL-X_CTRL-K*
CTRL-X CTRL-K		Поиск слов, начинающихся с символа перед курсором, в
			файлах, указанных в значении опции 'dictionary'. Это
			автодополнение похоже на CTRL-N, но вместо текущего
			файла поиск происходит в специальных файлах словарей.
			Найденное слово вставляется перед курсором. Это
			автодополнение может быть довольно медленным,
			поскольку до использования первого найденного
			соответствия происходит поиск всех возможных
			соответствий. По умолчанию опция 'dictionary' имеет
			пустое значение. 
			Советы о том, где найти файлы словарей содержатся в
			справке по опции 'dictionary'.


	CTRL-K	или
	CTRL-N		Поиск следующего соответствия далее по тексту.
			Найденное слово заменяет раннее найденное
			соответствие.

	CTRL-P		Поиск следующего соответствия в обратном направлении.
			Найденное слово заменяет раннее найденное
			соответствие.

							     *i_CTRL-X_CTRL-T*
CTRL-X CTRL-T		Работает почти так же, как и CTRL-X CTRL-K, но с
			важной особенностью. Вместо опции 'dictionary'
			используется значение опции 'thesaurus'. При этом,
			если обнаруживается соответствие, то в него входят все
			слова, расположенные в файле словаря синонимов на
			одной строке с соответствием, даже если они не
			являются прямым дополнением символов перед курсором.
			Таким образом, возможна полная замена слова.

			Представьте себе, что в файле, указанном в опции
			'thesaurus' есть такая строка: >

				добрый щедрый хороший 
<
			В этом случае, если курсор находится после букв "доб",
			то при вводе команды CTRL-X CTRL-T произойдёт
			дополнение слова "добрый"; последующий ввод этой
			команды изменит слово на "щедрый", а затем - на
			"хороший".
			Этой возможностью можно пользоваться для перевода
			текста на другой язык или для группировки функций в
			программном интерфейсе по ключевому слову.


	CTRL-T	или
	CTRL-N		Поиск следующего соответствия далее по тексту.
			Найденное слово заменяет раннее найденное
			соответствие.

	CTRL-P		Поиск следующего соответствия в обратном направлении.
			Найденное слово заменяет раннее найденное
			соответствие.


					   *автодополнение_по_ключевому_слову*
Автодополнение ключевых слов в текущем и включённых файлах     *compl-keyword*

Опция 'include' используется для указания строки, которая содержит имя
включённого файла. Поиск включённых файлов осуществляется по пути, указанному
в опции 'path'.

							     *i_CTRL-X_CTRL-I*
CTRL-X CTRL-I		Поиск первого ключевого слова в текущем и включённых
			файлах, которые начинаются с тех же символов, что и
			символы перед курсором. Найденное ключевое слово
			вставляется перед курсором.

	CTRL-N		Поиск следующего соответствия далее по тексту.
			Найденное соответствие заменяет ключевое слово,
			найденное прежде. 
			Замечание: символы CTRL-I и <Tab>, который вполне
			может быть введён после удачно найденного
			соответствия, имеют один и тот же код. По этой причине
			CTRL-I не используется для поиска следующего
			соответствия.

	CTRL-P		Поиск следующего соответствия в обратном направлении.
			Найденное слово заменяет раннее найденное
			соответствие.

	CTRL-X CTRL-I	Последующий ввод CTRL-X CTRL-I позволяет копировать
			слова, идущие по тексту сразу после найденного
			соответствия, если при этом не используется двойное
			CTRL-X.


Автодополнение меток	                    *автодополнение_меток* *compl-tag*

							     *i_CTRL-X_CTRL-]*
CTRL-X CTRL-]		Поиск первой метки, начинающейся с тех же символов,
			которые введены перед курсором. Найденная метка
			вставляется перед курсором. Для определения символов,
			которые могут быть в составе метки, используются те же
			правила, как и для ключевых слов, а именно - символы
			алфавита и символы, указанные в опции 'iskeyword'. См.
			также |CTRL-]|.
			Опция 'showfulltag' позволяет также добавить контекст
			метки из её определения.
			
	CTRL-]	или
	CTRL-N		Поиск следующего соответствия далее по тексту.
			Найденная метка заменяет раннее найденное
			соответствие.

	CTRL-P		Продолжить поиск соответствия в обратном направлении.
			Найденная метка заменяет предыдущее соответствие.


Автодополнение имён файлов	 *автодополнение_имён_файлов* *compl-filename*


							     *i_CTRL-X_CTRL-F*
CTRL-X CTRL-F		Поиск первого имени файла, которое начинается с тех же
			символов, что и символы перед курсором. Найденное имя
			вставляется перед курсором. В составе имени файла
			могут быть символы алфавита и символы, указанные в
			значении опции 'isfname'. Замечание: значение опции
			'path' в данном случае (пока) не используется.

	CTRL-F	или
	CTRL-N		Поиск следующего совпадающего имени файла далее по
			тексту. Найденное имя файла заменяет раннее найденное
			соответствие.

	CTRL-P		Поиск предыдущего совпадающего имени файла в обратном
			направлении. Найденное имя файла заменяет раннее найденное
			соответствие.


Автодополнение определений и макросов   *compl-define* *автодополнение-define*

Опция 'define' используется для указания строки, в которой содержатся
определения. Опция 'include' используется для указания строки, в которой
содержится ссылка на включённый файл. Опция 'path' используется для поиска
включённых файлов.

							     *i_CTRL-X_CTRL-D*
CTRL-X CTRL-D		Поиск первого определения (или макроса), которое
			начинается с символов перед курсором в текущем и
			включённых файлах. Найденное определение вставляется
			перед курсором. 
			
	CTRL-D	или
	CTRL-N		Поиск следующего определения или макроса. Найденное
			имя заменяет раннее найденное соответствие.

	CTRL-P		Поиск предыдущего определения или макроса в обратном
			направлении. Найденное имя заменяет раннее найденное
			соответствие.

	CTRL-X CTRL-D	Повторное использование CTRL-X CTRL-D позволяет
			копировать слова, следующие за раннее найденным
			соответствием в других контекстах, если при этом не
			используется двойное CTRL-X.


Автодополнение команд Vim	              *compl-vim* *автодополнение-vim*

Автодополнение зависит от контекста и работает так же как и в Командной
строке. Оно позволяет ввести команду Ex вместе с параметрами. 

							     *i_CTRL-X_CTRL-V*
CTRL-X CTRL-V		Попытаться определить что находится перед курсором и
			найти первое соответствие, начинающееся с тех же
			символов.
			Замечание: Если CTRL-V используется в привязках, то
			можно попытаться использовать CTRL-Q вместо него
			|i_CTRL-Q|.

	CTRL-V или
	CTRL-N		Поиск следующего соответствия. Найденное соответствие
			заменяет раннее найденное.

	CTRL-P		Поиск предыдущего соответствия в обратном направлении. 
			Найденное соответствие заменяет раннее найденное.

	CTRL-X CTRL-V	Повторное использование CTRL-X CTRL-V работает так же,
			как и CTRL-V. Это позволяет устроить привязку для
			выполнения автодополнения команды Vim, например: >
				
				:imap <Tab> <C-X><C-V>

<
						       *автодополнение-общее*
Автодополнение ключевых слов из разных источников             *compl-generic* 

							           *i_CTRL-N*
CTRL-N			Найти следующее соответствие для слов, начинающихся с
			символов перед курсором; поиск происходит в местах,
			указанных в значении опции 'complete'. Найденное
			слово вставляется перед курсором.

							           *i_CTRL-P*
CTRL-P			Найти предыдущее соответствие для слов, начинающихся
                        с символов перед курсором; поиск происходит в местах,
			указанных в значении опции 'complete'. Найденное
			слово вставляется перед курсором.

	CTRL-N		Продолжить поиск соответствия. Следующее найденное
			соответствие заменяет раннее найденное.

	CTRL-P		Продолжить поиск соответствия в обратном направлении.
			Найденное соответствие заменяет раннее найденное.

	CTRL-X CTRL-N или
	CTRL-X CTRL-P	
	                Повторное использование CTRL-X CTRL-N или CTRL-X
			CTRL-P копирует слова, следующие за найденным
			соответствием в других контекстах, если при этом не
			используется двойное CTRL-X.

==============================================================================
8. Команды режима Вставки			         *inserting* *вставка*

Следующие команды используются для вставки нового текста в буфер. Все эти
команды могут быть отменены или повторены с помощью команды ".".

							                   *a*
a			Добавить текст после курсора заданное [число] раз.
                        Если курсор находится в первой колонке пустой строки,
			то Вставка начинается с этого места, кроме случая,
			когда включена опция 'virtualedit'.			

							                   *A*
A			Добавить текст в конце строки заданное [число] раз.

<insert>	или		                       *i* *insert* *<Insert>* 
i			Вставить текст перед курсором заданное [число] раз.
			При использовании CTRL-O в режиме Вставки |i_CTRL-O|
			[число] не используется.

							                   *I*
I			Вставить текст перед первым непробельным символом в
			строке заданное [число] раз.

							                  *gI*
gI			Вставить текст в колонке 1 заданное [число] раз.
			{Vi не имеет такой возможности}

							                  *gi*
gi			Вставить текст в той же позиции, где режим Вставки в
			текущем буфере был прекращён до этого. При этом
			используется значение отметки |'^|, что отличается от
			"`^i", если отметка находится после конца строки.
			Позиция автоматически подстраивается при добавлении
			или удалении строк, НО не символов. 
			При использовании команды-модификатора |:keepjumps|,
			отметка |'^| не изменяется.
			{Vi не имеет такой возможности}

							                   *o*
o			Начать новую строку под курсором и перейти к вставке
			текста; операция может повторяться заданное [число]
			раз.
			{Vi: очищается заданное [число] экранных строк}

							                   *O*
O			Начать новую строку над курсором и перейти к вставке
			текста; операция может повторяться заданное [число]
			раз.
			{Vi: очищается заданное [число] экранных строк}

Эти команды используются для начала вставки текста. Режим вставки может быть
прекращён с помощью кнопки <Esc>. О других специальных символах в режиме
Вставки см. |режим_вставки_и_замены|. Влияние [числа] проявляется после выхода
из режима Вставки.

При включённой опции 'autoindent' отступ для новой строки наследуется из
предыдущей строки. Если включена опция 'smartindent' или 'cindent', то отступ
строки в стиле программ на языке C настраивается автоматически.

Опция 'textwidth' может содержать величину максимальной ширины строки. Если
строка становится слишком длинной, то при добавлении символов автоматически
вставляется перенос строки.

==============================================================================
9. Команды вставки Ex 			           *inserting-ex* *вставка-ex*

							        *:a* *:append*
:{диапазон}a[ppend]	Вставка нескольких строк текста под указанной строкой.
			Если {диапазон} не указан, то текст будет вставлен
			после текущей строки.

							  *:i* *:in* *:insert*
:{диапазон}i[nsert]	Вставка нескольких строк текста над указанной строкой.
			Если {диапазон} не указан, то текст будет вставлен
			перед текущей строкой.

Эти команды будут запрашивать строки до тех пор, пока вы не введёте строку,
содержащую единственный символ ".". Следите за строками, которые начинаются с
обратной косой черты, подробнее см. |продолжение_строки|.
ЗАМЕЧАНИЕ: команды ":append" и ":insert" не работают как следует между ":if" и
":endif".

						       *:start* *:startinsert*
:star[tinsert][!]	Перейти в режим Вставки сразу после выполнения этой
			команды. Команда работает точно так же, как и ввод
			команды "i" в Обычном режиме. При использовании !
			команда работает так же, как и "A", позволяя вставлять
			символы в конец строки. Без ! вставка происходит в
			позиции курсора. 
			Обратите внимание, что при использовании этой команды
			в функции или сценарии, вставка начинается только
			после окончания выполнения функции или сценария.
			{Vi не имеет такой возможности}
                        {доступно только в том случае, если Vim скомпилирован
			с особенностью +ex_extra}

							*:stopi* *:stopinsert*
:stopi[nsert]		Остановить режим Вставки при первой же возможности.
			Команда работает точно так же, как и ввод <Esc> в
			режиме Вставки.
			Эта команда может использоваться в автокомандах,
			например: >
			
				:au BufEnter scratch stopinsert

==============================================================================
10. Вставка содержимого файла                 *inserting-file* *вставка-файла*

							    *:r* *:re* *:read*
:r[ead] [имя]		Вставить файл [имя] (по умолчанию: текущий файл) ниже
			курсора.

:{диапазон}r[ead] [имя]	Вставить файл [имя] (по умолчанию: текущий файл) под
			указанной строкой.

							        *:r!* *:read!*
:r[ead] !{команда}	Выполнить {команду} и вставить её стандартный вывод
			под курсором. Для хранения содержимого потока
			стандартного вывода используется временный файл,
			который затем вставляется в буфер. Опция 'shellredir'
			задаёт параметры сохранения вывода команды и может
			быть настроена таким образом, чтобы также включать
			стандартный поток ошибок stderr. {команда} выполняется
			как ":!{команда}", все символы '!' заменяются на
			предыдущую команду |:!|.

Эти команды вставляют содержимое файла или вывод команды в буфер. Результат
работы этих команд не может быть отменён. Их также нельзя повторить по команде
".". В этих командах позиция курсора или диапазон определяют строку, под
которой начинается вставка. Для вставки текста над первой строкой используйте
команду ":0r {имя}".

После команды ":read" курсор остаётся на первом непробельном символе в первой
новой строке. В режиме Ex, однако, курсор остаётся на последней новой строке
(к сожалению, этого требует совместимость с Vi).

Файл, имя которого указано в качестве параметра ":r", становится соседним
файлом. Этим можно пользоваться, например, если вы хотите редактировать
непосредственно этот файл: ":e! #". Такое поведение можно отключить, убрав из
значения опции 'cpoptions' флаг 'a'.

					             *file-read* *файл-чтение*
Опция 'fileformat' задаёт стиль переноса строки <EOL> для файла:

'fileformat'    символы		   имя				~
  "dos"		<CR><NL> или <NL>  формат DOS
  "unix"	<NL>		   формат Unix
  "mac"		<CR>		   формат Mac
  
Раннее той же цели служила опция 'textmode'. В современных версиях она не
используется.

Если значение опции 'fileformat' -- "dos", то <CR> перед <NL> игнорируется, а
также игнорируется CTRL-Z в конце файла.

Если значение опции 'fileformat' -- "mac", то <NL> в файле представляется с
помощью символа <CR>. Это необходимо для того, чтобы избежать путаницы, когда
<NL> используется для представления символа <NUL>. См. |CR-вместо-NL|.

Если значение опции 'fileformats' не является пустой строкой, то Vim пытается
определить тип конца строки <EOL> (см. |файл-форматы|). Следует заметить, что
значение опции 'fileformat' при этом не будет изменено; определённый формат
файла будет использоваться только при чтении файла. Аналогичный процесс
происходит и с 'fileencodings'.

На системах, отличных от MS-DOS, Win32 и OS/2, при чтении файла в формате DOS
показывается сообщение "[формат dos]", чтобы напомнить вам о том, что
происходит. На Макинтоше, MS-DOS, Win32 и OS/2 при чтении файла в формате Unix
показывается сообщение "[формат unix]".
На системах, отличных от Макинтоша, при чтении файла в формате Mac
показывается сообщение "[формат mac]".

Пример использования ":r !": >

	:r !uuencode binfile binfile

Эта команда читает файл "binfile", декодирует его с помощью команды "uuencode"
и вставляет его в текущий буфер. Такое использование может быть полезным при
редактировании сообщения электронной почты, когда вам хочется вставить в
сообщение бинарный файл.

					    *read-messages* *чтение-сообщения*
При чтении файла Vim показывает сообщение с информацией о прочтённом файле. В
таблице ниже приводятся пояснения для некоторых сообщений. Другие сообщения
не требуют пояснений. Использование короткой или длинной формы сообщений
зависит от установки опции 'shortmess'.

	длинная форма   короткая форма  значение ~
	[только чтение]	[RO]		файл защищён от записи
	[fifo/гнездо]			используется поток
	[fifo]				используется поток fifo
	[гнездо]			используется поток из гнезда
	[пропущены CR]			при чтении файла со значением опции
					'fileformat' равным "dos" обнаружены
					символы NL без предшествующих символов
					CR.
	[обнаружены NL]			при чтении файла со значением опции
					'fileformat' равным "mac" обнаружены
					символы NL (файл может быть в формате
					"unix").
	[длинные строки поделены]	по крайней мере одна строка была
					разделена на две
	[БЕЗ преобразований]		Было желательно преобразование из
					кодировки, указанной в значении опции
					'fileencoding', в кодировку, указанную
					в значении опции 'encoding', но оно не
					было возможно.
	[перекодировано]		Было выполнено преобразование из
					кодировки, указанной в значении опции
					'fileencoding', в кодировку, указанную
					в значении опции 'encoding'.
	[зашифровано]			файл был расшифрован
	[ОШИБКИ ЧТЕНИЯ]			файл был прочитан не полностью

==============================================================================
vim:tw=78:ts=8:ft=help:norl:
